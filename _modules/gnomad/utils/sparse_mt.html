

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gnomad.utils.sparse_mt &mdash; gnomad master documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> gnomad
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>gnomad.utils.sparse_mt</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gnomad.utils.sparse_mt</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">.annotations</span> <span class="kn">import</span> <span class="n">get_lowqual_expr</span>
<span class="kn">from</span> <span class="nn">.generic</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.gnomad_functions</span> <span class="kn">import</span> <span class="n">get_adj_expr</span>

<span class="n">INFO_SUM_AGG_FIELDS</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;QUALapprox&#39;</span><span class="p">]</span>
<span class="n">INFO_INT32_SUM_AGG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;VarDP&#39;</span><span class="p">]</span>
<span class="n">INFO_MEDIAN_AGG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ReadPosRankSum&#39;</span><span class="p">,</span> <span class="s1">&#39;MQRankSum&#39;</span><span class="p">]</span>
<span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;SB&#39;</span><span class="p">,</span> <span class="s1">&#39;RAW_MQandDP&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="compute_last_ref_block_end"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.compute_last_ref_block_end">[docs]</a><span class="k">def</span> <span class="nf">compute_last_ref_block_end</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function takes a sparse MT and computes for each row the genomic position of the</span>
<span class="sd">    most upstream reference block overlapping that row.</span>

<span class="sd">    Note that since reference blocks do not extend beyond contig boundaries, only the position is kept.</span>

<span class="sd">    This function returns a Table with that annotation.  (`last_END_position`).</span>

<span class="sd">    :param mt: Input MatrixTable</span>
<span class="sd">    :return: Output Table with `last_END_position` annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span><span class="s1">&#39;END&#39;</span><span class="p">)</span>

    <span class="c1"># Localize entries, so that they can be viewed as an array and scanned over using hl.scan.array_agg</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">_localize_entries</span><span class="p">(</span><span class="s1">&#39;__entries&#39;</span><span class="p">,</span> <span class="s1">&#39;__cols&#39;</span><span class="p">)</span>

    <span class="c1"># Compute the position by using hl.scan._prev_nonnull.</span>
    <span class="c1"># This was inspired by hl.experimental.densify</span>
    <span class="c1"># _prev_non_null is an aggregator that keeps the previous record in memory</span>
    <span class="c1"># and updates it with the given value at the row if it&#39;s not null (missing)</span>
    <span class="c1"># The following code computes the following annotation for each row:</span>
    <span class="c1"># 1. Keep a scan of the entries using _prev_nonnull, keeping the start (ht.locus) and end (entry.END) of each ref block  (1.1)</span>
    <span class="c1"># 2. For the current row locus, record the start of the block that starts the furthest away,</span>
    <span class="c1">#    that is the minimum position in the current scan for any block that overlaps the current locus (2.1)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="n">last_END_position</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>  <span class="c1"># 2. For the current row locus, record the start of the block that starts the furthest away</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">entry</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">_prev_nonnull</span><span class="p">(</span>  <span class="c1"># 1. Keep a scan of the entries using _prev_nonnull</span>
                        <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">END</span><span class="p">),</span>  <span class="c1"># Update the scan whenever a new ref block is encountered</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">tuple</span><span class="p">([</span>  <span class="c1"># 1.1 keep the start (ht.locus) and end (entry.END) of each ref block</span>
                                <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span>
                                <span class="n">entry</span><span class="o">.</span><span class="n">END</span>
                            <span class="p">])</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">ht</span><span class="o">.</span><span class="n">__entries</span>
                <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>  <span class="c1"># 2.1 get the start position of blocks that overlap the current locus</span>
                        <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contig</span> <span class="o">==</span> <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span><span class="p">),</span>
                        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">()</span></div>


<div class="viewcode-block" id="densify_sites"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.densify_sites">[docs]</a><span class="k">def</span> <span class="nf">densify_sites</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
        <span class="n">sites_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
        <span class="n">last_END_positions_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
        <span class="n">semi_join_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a dense version of the input sparse MT at the sites in `sites_ht` reading the minimal amount of data required.</span>

<span class="sd">    Note that only rows that appear both in `mt` and `sites_ht` are returned.</span>

<span class="sd">    :param mt: Input sparse MT</span>
<span class="sd">    :param sites_ht: Desired sites to densify</span>
<span class="sd">    :param last_END_positions_ht: Table storing positions of the furthest ref block (END tag)</span>
<span class="sd">    :param semi_join_rows: Whether to filter the MT rows based on semi-join (default, better if sites_ht is large) or based on filter_intervals (better if sites_ht only contains a few sites)</span>
<span class="sd">    :return: Dense MT filtered to the sites in `sites_ht`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing intervals to densify from sites Table.&quot;</span><span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s1">&#39;locus&#39;</span><span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">interval</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">locus_interval</span><span class="p">(</span>
            <span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span>
            <span class="n">last_END_positions_ht</span><span class="p">[</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">last_END_position</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
            <span class="n">includes_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">reference_genome</span><span class="o">=</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">reference_genome</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">interval</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">semi_join_rows</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s1">&#39;interval&#39;</span><span class="p">)[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Collecting intervals to densify.&quot;</span><span class="p">)</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> intervals, totalling </span><span class="si">{1}</span><span class="s2"> bp in the dense Matrix.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">),</span>
            <span class="nb">sum</span><span class="p">([</span><span class="n">interval_length</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">union_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">)])</span>
        <span class="p">))</span>

        <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">intervals</span><span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">densify</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">])</span>
    <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_get_info_agg_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_SUM_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_INT32_SUM_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_MEDIAN_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Aggregation</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function containing code to create Aggregators for both site or AS info expression aggregations.</span>

<span class="sd">    Notes:</span>

<span class="sd">    1. If `SB` is specified in array_sum_agg_fields, it will be aggregated as `AS_SB_TABLE`, according to GATK standard nomenclature.</span>
<span class="sd">    2. If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">    3. If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">    4. If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`, `median_agg_fields`) are passed as list of str,</span>
<span class="sd">       then they should correspond to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">       Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in case of a name clash.</span>

<span class="sd">    :param mt: Input MT</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using element-wise summing over an array.</span>
<span class="sd">    :param prefix: Optional prefix for the fields. Used for adding &#39;AS_&#39; in the AS case.</span>

<span class="sd">    :return: Dictionary of expression names and their corresponding aggregation Expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]:</span>
        <span class="n">out_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;gvcf_info&#39;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
            <span class="n">out_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">}</span>

        <span class="n">out_fields</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">mt</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="c1">#Check that all fields were found</span>
        <span class="n">missing_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_fields</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_fields</span><span class="p">:</span>
            <span class="k">raise</span>  <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find the following field(s)in the MT entry schema (or nested under mt.gvcf_info: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_fields</span><span class="p">)</span>
            <span class="p">))</span>

        <span class="k">return</span> <span class="n">out_fields</span>

    <span class="c1"># Map str to expressions where needed</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">sum_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">int32_sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">int32_sum_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">median_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">median_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">median_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array_sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">array_sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">array_sum_agg_fields</span><span class="p">)</span>

    <span class="c1"># Create aggregators</span>
    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}{k}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">approx_quantiles</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">median_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}{k}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">sum_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}{k}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">int32_sum_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">})</span>
    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}{k}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">expr</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">array_sum_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">})</span>

    <span class="c1"># Handle annotations combinations and casting for specific annotations</span>

    <span class="c1"># If RAW_MQandDP is in agg_expr or if both MQ_DP and RAW_MQ are, compute MQ instead</span>
    <span class="n">mq_tuple</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">RAW_MQandDP&#39;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Computing </span><span class="si">{prefix}</span><span class="s2">MQ as sqrt(</span><span class="si">{prefix}</span><span class="s2">RAW_MQandDP[0]/</span><span class="si">{prefix}</span><span class="s2">RAW_MQandDP[1]). &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Note that </span><span class="si">{prefix}</span><span class="s2">MQ will be set to 0 if </span><span class="si">{prefix}</span><span class="s2">RAW_MQandDP[1] == 0.&quot;</span>
        <span class="p">)</span>
        <span class="n">mq_tuple</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">RAW_MQandDP&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">RAW_MQ&#39;</span> <span class="ow">in</span> <span class="n">agg_expr</span> <span class="ow">and</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">MQ_DP&#39;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Computing </span><span class="si">{prefix}</span><span class="s2">MQ as sqrt(</span><span class="si">{prefix}</span><span class="s2">MQ_DP/</span><span class="si">{prefix}</span><span class="s2">RAW_MQ). &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Note that MQ will be set to 0 if </span><span class="si">{prefix}</span><span class="s2">RAW_MQ == 0.&quot;</span>
        <span class="p">)</span>
        <span class="n">mq_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">MQ_DP&#39;</span><span class="p">),</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">RAW_MQ&#39;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">mq_tuple</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">MQ&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">mq_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mq_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mq_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
            <span class="mi">0</span>
        <span class="p">)</span>

    <span class="c1"># If both VarDP and QUALapprox are present, also compute QD.</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{prefix}</span><span class="s2">VarDP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{prefix}</span><span class="s2">QUALapprox&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Computing </span><span class="si">{prefix}</span><span class="s2">QD as </span><span class="si">{prefix}</span><span class="s2">QUALapprox/</span><span class="si">{prefix}</span><span class="s2">VarDP. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Note that </span><span class="si">{prefix}</span><span class="s2">QD will be set to 0 if </span><span class="si">{prefix}</span><span class="s2">VarDP == 0.&quot;</span>
        <span class="p">)</span>
        <span class="n">var_dp</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">[</span><span class="s1">&#39;VarDP&#39;</span><span class="p">]))</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">QD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">var_dp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{prefix}</span><span class="s2">QUALapprox&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">var_dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># SB needs to be cast to int32 for FS down the line</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">SB&#39;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">SB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{prefix}</span><span class="s1">SB&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">agg_expr</span>


<div class="viewcode-block" id="get_as_info_expr"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_as_info_expr">[docs]</a><span class="k">def</span> <span class="nf">get_as_info_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_SUM_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="p">:</span>  <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_INT32_SUM_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="p">:</span>  <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_MEDIAN_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an allele-specific annotation Struct containing typical VCF INFO fields from GVCF INFO fields stored in the MT entries.</span>

<span class="sd">    Notes:</span>

<span class="sd">    1. If `SB` is specified in array_sum_agg_fields, it will be aggregated as `AS_SB_TABLE`, according to GATK standard nomenclature.</span>
<span class="sd">    2. If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">    3. If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">    4. If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`, `median_agg_fields`) are passed as list of str,</span>
<span class="sd">       then they should correspond to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">       Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in case of a name clash.</span>

<span class="sd">    :param mt: Input Matrix Table</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :return: Expression containing the AS info fields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;DP&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;`DP` was included in allele-specific aggregation, &quot;</span>
            <span class="s2">&quot;however `DP` is typically not aggregated by allele; `VarDP` is.&quot;</span>
            <span class="s2">&quot;Note that the resulting `AS_DP` field will NOT include reference genotypes.&quot;</span>
        <span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">_get_info_agg_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">=</span><span class="n">mt</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="o">=</span><span class="n">sum_agg_fields</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="o">=</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="o">=</span><span class="n">median_agg_fields</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="o">=</span><span class="n">array_sum_agg_fields</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;AS_&#39;</span>
    <span class="p">)</span>

    <span class="c1"># Rename AS_SB to AS_SB_TABLE if present</span>
    <span class="k">if</span> <span class="s1">&#39;AS_SB&#39;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s1">&#39;AS_SB_TABLE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;AS_SB&#39;</span><span class="p">)</span>

    <span class="c1"># Modify aggregations to aggregate per allele</span>
    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span>
                <span class="n">expr</span>
            <span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="c1"># Run aggregations</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="o">**</span><span class="n">agg_expr</span>
    <span class="p">)</span>

    <span class="c1"># Add SB Ax2 aggregation logic and FS if SB is present</span>
    <span class="k">if</span> <span class="s1">&#39;AS_SB_TABLE&#39;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">as_sb_table</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="n">info</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># ref</span>
        <span class="p">])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">info</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>  <span class="c1"># each alt</span>
        <span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AS_SB_TABLE</span><span class="o">=</span><span class="n">as_sb_table</span><span class="p">,</span>
            <span class="n">AS_FS</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">fs_from_sb</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="get_site_info_expr"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_site_info_expr">[docs]</a><span class="k">def</span> <span class="nf">get_site_info_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_SUM_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="p">:</span>  <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_INT32_SUM_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="p">:</span>  <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_MEDIAN_AGG_FIELDS</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="n">INFO_ARRAY_SUM_AGG_FIELDS</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a site-level annotation Struct aggregating typical VCF INFO fields from GVCF INFO fields stored in the MT entries.</span>

<span class="sd">    Notes:</span>

<span class="sd">    1. If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">    2. If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">    3. If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`, `median_agg_fields`) are passed as list of str,</span>
<span class="sd">       then they should correspond to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">       Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in case of a name clash.</span>

<span class="sd">    :param mt: Input Matrix Table</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :return: Expression containing the site-level info fields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;DP&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;`DP` was included in site-level aggregation. This requires a densifying prior to running get_site_info_expr&quot;</span><span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">_get_info_agg_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">=</span><span class="n">mt</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="o">=</span><span class="n">sum_agg_fields</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="o">=</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="o">=</span><span class="n">median_agg_fields</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="o">=</span><span class="n">array_sum_agg_fields</span>
    <span class="p">)</span>

    <span class="c1"># Add FS if SB is present</span>
    <span class="c1"># This is done outside of _get_info_agg_expr as the behavior is different in site vs allele-specific versions</span>
    <span class="n">agg_expr</span><span class="p">[</span><span class="s1">&#39;FS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs_from_sb</span><span class="p">(</span><span class="n">agg_expr</span><span class="p">[</span><span class="s1">&#39;SB&#39;</span><span class="p">])</span>

    <span class="c1"># Run aggregator on non-ref genotypes</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s1">&#39;DP&#39;</span><span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Add DP, computed over both ref and non-ref genotypes, if present</span>
    <span class="k">if</span> <span class="s1">&#39;DP&#39;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">DP</span><span class="o">=</span><span class="n">agg_expr</span><span class="p">[</span><span class="s1">&#39;DP&#39;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="default_compute_info"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.default_compute_info">[docs]</a><span class="k">def</span> <span class="nf">default_compute_info</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">site_annotations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">n_partitions</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes a HT with the typical GATK allele-specific (AS) info fields </span>
<span class="sd">    as well as ACs and lowqual fields.</span>
<span class="sd">    Note that this table doesn&#39;t split multi-allelic sites.</span>

<span class="sd">    :param mt: Input MatrixTable. Note that this table should be filtered to nonref sites.</span>
<span class="sd">    :param site_annotations: Whether to also generate site level info fields. Default is False.</span>
<span class="sd">    :param n_partitions: Number of desired partitions for output Table. Default is 5000.</span>
<span class="sd">    :return: Table with info fields</span>
<span class="sd">    :rtype: Table</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Move gvcf info entries out from nested struct</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">transmute_entries</span><span class="p">(</span><span class="o">**</span><span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">)</span>

    <span class="c1"># Compute AS info expr</span>
    <span class="n">info_expr</span> <span class="o">=</span> <span class="n">get_as_info_expr</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">site_annotations</span><span class="p">:</span>
        <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="o">**</span><span class="n">get_site_info_expr</span><span class="p">(</span>
                <span class="n">mt</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Add AC and AC_raw:</span>
    <span class="c1"># First compute ACs for each non-ref allele, grouped by adj</span>
    <span class="n">grp_ac_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
                <span class="n">get_adj_expr</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">LAD</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">x</span><span class="p">)))[</span><span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ai</span><span class="p">)]</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="c1"># Then, for each non-ref allele, compute</span>
    <span class="c1"># AC as the adj group</span>
    <span class="c1"># AC_raw as the sum of adj and non-adj groups</span>
    <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">AC_raw</span><span class="o">=</span><span class="n">grp_ac_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">))),</span>
        <span class="n">AC</span><span class="o">=</span><span class="n">grp_ac_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
    <span class="p">)</span>

    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span>
        <span class="n">info</span><span class="o">=</span><span class="n">info_expr</span>
    <span class="p">)</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>

    <span class="c1"># Add lowqual flag</span>
    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">lowqual</span><span class="o">=</span><span class="n">get_lowqual_expr</span><span class="p">(</span>
            <span class="n">info_ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span>
            <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">QUALapprox</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">naive_coalesce</span><span class="p">(</span><span class="n">n_partitions</span><span class="p">)</span></div>


<div class="viewcode-block" id="split_info_annotation"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.split_info_annotation">[docs]</a><span class="k">def</span> <span class="nf">split_info_annotation</span><span class="p">(</span>
    <span class="n">info_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span>
    <span class="n">a_index</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits multi-allelic allele-specific info fields.</span>

<span class="sd">    :param info_expr: Field containing info struct.</span>
<span class="sd">    :param a_index: Allele index. Output by hl.split_multi or hl.split_multi_hts.</span>
<span class="sd">    :return: Info struct with split annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Index AS annotations</span>
    <span class="n">info_expr</span><span class="o">=</span><span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">info_expr</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">a_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">info_expr</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;AC&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;AS_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span> <span class="o">==</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">)},</span>
        <span class="n">AS_SB_TABLE</span><span class="o">=</span><span class="n">info_expr</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">info_expr</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="p">[</span><span class="n">a_index</span><span class="p">])</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">info_expr</span></div>


<div class="viewcode-block" id="split_lowqual_annotation"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.split_lowqual_annotation">[docs]</a><span class="k">def</span> <span class="nf">split_lowqual_annotation</span><span class="p">(</span>
    <span class="n">lowqual_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">a_index</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits multi-allelic low QUAL annotation.</span>

<span class="sd">    :param lowqual_expr: Field containing low QUAL annotation.</span>
<span class="sd">    :param a_index: Allele index. Output by hl.split_multi or hl.split_multi_hts.</span>
<span class="sd">    :return: Low QUAL expression for particular allele.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">lowqual_expr</span><span class="p">[</span><span class="n">a_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="impute_sex_ploidy"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.impute_sex_ploidy">[docs]</a><span class="k">def</span> <span class="nf">impute_sex_ploidy</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
        <span class="n">excluded_intervals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">included_intervals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">normalization_contig</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;chr20&#39;</span><span class="p">,</span>
        <span class="n">chr_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chr_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span> <span class="c1"># TODO: For exomes, calling intervals need to be added</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Imputes sex ploidy from a sparse Matrix Table by normalizing the coverage of chromosomes X and Y using</span>
<span class="sd">    the coverage of an autosomal chromosome (by default chr20).</span>
<span class="sd">    Coverage is computed using the median block coverage (summed over the block size) and the non-ref coverage at non-ref genotypes.</span>

<span class="sd">    :param mt: Input sparse Matrix Table</span>
<span class="sd">    :param excluded_intervals: Optional table of intervals to exclude from the computation.</span>
<span class="sd">    :param included_intervals: Optional table of intervals to use in the computation. REQUIRED for exomes.</span>
<span class="sd">    :param normalization_contig: Which chromosome to normalize by</span>
<span class="sd">    :param chr_x: Optional X Chromosome contig name (by default uses the X contig in the reference)</span>
<span class="sd">    :param chr_y: Optional Y Chromosome contig name (by default uses the Y contig in the reference)</span>
<span class="sd">    :return: Table with mean coverage over chromosomes 20, X and Y and sex chromosomes ploidy based on normalized coverage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ref</span> <span class="o">=</span> <span class="n">get_reference_genome</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span> <span class="n">add_sequence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">chr_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> X chromosome contigs (</span><span class="si">{1}</span><span class="s2">) in Genome reference. sparse_impute_sex_ploidy currently only supports a single X chromosome contig. Please use the `chr_x` argument to  specify which X chromosome contig to use &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">),</span>
                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">chr_x</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">chr_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> Y chromosome contigs (</span><span class="si">{1}</span><span class="s2">) in Genome reference. sparse_impute_sex_ploidy currently only supports a single Y chromosome contig. Please use the `chr_y` argument to  specify which Y chromosome contig to use &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">),</span>
                    <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">chr_y</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_contig_size</span><span class="p">(</span><span class="n">contig</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Working on </span><span class="si">{contig}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">range_table</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">contig</span><span class="p">),</span> <span class="n">n_partitions</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span> <span class="o">/</span> <span class="mi">500_000</span><span class="p">))</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">locus</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">locus</span><span class="p">(</span><span class="n">contig</span><span class="o">=</span><span class="n">contig</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reference_genome</span><span class="o">=</span><span class="n">ref</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">sequence_context</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;n&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">())</span>

        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s1">&#39;locus&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">included_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">included_intervals</span><span class="p">[</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">key</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">excluded_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">excluded_intervals</span><span class="p">[</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">key</span><span class="p">]))</span>
        <span class="n">contig_size</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Contig </span><span class="si">{contig}</span><span class="s2"> has </span><span class="si">{contig_size}</span><span class="s2"> bases for coverage.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">contig_size</span>

    <span class="k">def</span> <span class="nf">get_chr_dp_ann</span><span class="p">(</span><span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
        <span class="n">contig_size</span> <span class="o">=</span> <span class="n">get_contig_size</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span>
        <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">parse_locus_interval</span><span class="p">(</span><span class="n">chrom</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">:</span>
            <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">:</span>
            <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">included_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">included_intervals</span><span class="p">[</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">select_cols</span><span class="p">(</span><span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{chrom}</span><span class="s1">_mean_dp&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">(),</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">DP</span> <span class="o">*</span> <span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">END</span> <span class="o">-</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">),</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">DP</span><span class="p">))</span> <span class="o">/</span> <span class="n">contig_size</span>
        <span class="p">})</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>

    <span class="n">normalization_chrom_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">normalization_contig</span><span class="p">)</span>
    <span class="n">chrX_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">chr_x</span><span class="p">)</span>
    <span class="n">chrY_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">chr_y</span><span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="n">chrX_dp</span><span class="p">[</span><span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">key</span><span class="p">],</span>
        <span class="o">**</span><span class="n">chrY_dp</span><span class="p">[</span><span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">key</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{chr_x}</span><span class="s1">_ploidy&#39;</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{chr_x}</span><span class="s1">_mean_dp&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{normalization_contig}</span><span class="s1">_mean_dp&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{chr_y}</span><span class="s1">_ploidy&#39;</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{chr_y}</span><span class="s1">_mean_dp&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{normalization_contig}</span><span class="s1">_mean_dp&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>