

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gnomad.utils.generic &mdash; gnomad master documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> gnomad
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>gnomad.utils.generic</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gnomad.utils.generic</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>
<span class="kn">from</span> <span class="nn">hail.expr.expressions</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">hail.utils.misc</span> <span class="kn">import</span> <span class="n">divide_null</span>
<span class="kn">from</span> <span class="nn">.gnomad_functions</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">gnomad.resources.resource_utils</span> <span class="kn">import</span> <span class="n">DataException</span>

<span class="n">INFO_VCF_AS_PIPE_DELIMITED_FIELDS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AS_QUALapprox&#39;</span><span class="p">,</span> <span class="s1">&#39;AS_VarDP&#39;</span><span class="p">,</span> <span class="s1">&#39;AS_MQ_DP&#39;</span><span class="p">,</span> <span class="s1">&#39;AS_RAW_MQ&#39;</span><span class="p">,</span> <span class="s1">&#39;AS_SB_TABLE&#39;</span><span class="p">]</span>

<span class="n">VEP_REFERENCE_DATA</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;GRCh37&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;vep_config&#39;</span><span class="p">:</span> <span class="s1">&#39;gs://hail-common/vep/vep/vep85-loftee-gcloud.json&#39;</span><span class="p">,</span>
        <span class="s1">&#39;all_possible&#39;</span><span class="p">:</span> <span class="s1">&#39;gs://gnomad-public/papers/2019-flagship-lof/v1.0/context/Homo_sapiens_assembly19.fasta.snps_only.vep_20181129.ht&#39;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s1">&#39;GRCh38&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s1">&#39;vep_config&#39;</span><span class="p">:</span> <span class="s1">&#39;gs://hail-common/vep/vep/vep95-GRCh38-loftee-gcloud.json&#39;</span><span class="p">,</span>
        <span class="s1">&#39;all_possible&#39;</span><span class="p">:</span> <span class="s1">&#39;gs://gnomad-public/resources/context/grch38_context_vep_annotated.ht&#39;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>


<div class="viewcode-block" id="file_exists"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.file_exists">[docs]</a><span class="k">def</span> <span class="nf">file_exists</span><span class="p">(</span><span class="n">fname</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check whether a file exists.</span>
<span class="sd">    Supports either local or Google cloud (gs://) paths.</span>
<span class="sd">    If the file is a Hail file (.ht, .mt extensions), it checks that _SUCCESS is present.</span>

<span class="sd">    :param fname: File name</span>
<span class="sd">    :return: Whether the file exists</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fext</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.ht&#39;</span><span class="p">,</span> <span class="s1">&#39;.mt&#39;</span><span class="p">]:</span>
        <span class="n">fname</span> <span class="o">+=</span> <span class="s1">&#39;/_SUCCESS&#39;</span>
    <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;gs://&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">hadoop_exists</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></div>


<div class="viewcode-block" id="unphase_mt"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.unphase_mt">[docs]</a><span class="k">def</span> <span class="nf">unphase_mt</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate unphased version of MatrixTable (assumes call is in mt.GT and is diploid or haploid only)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_entries</span><span class="p">(</span><span class="n">GT</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
                               <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">is_diploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                               <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                               <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">))</span>
                               <span class="p">)</span></div>


<div class="viewcode-block" id="add_reference_sequence"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.add_reference_sequence">[docs]</a><span class="k">def</span> <span class="nf">add_reference_sequence</span><span class="p">(</span><span class="n">ref</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">ReferenceGenome</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">ReferenceGenome</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds the fasta sequence to a Hail reference genome.</span>
<span class="sd">    Only GRCh37 and GRCh38 references are supported.</span>

<span class="sd">    :param ref: Input reference genome.</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">ref</span><span class="o">.</span><span class="n">has_sequence</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;GRCh38&#39;</span><span class="p">:</span>
            <span class="n">ref</span><span class="o">.</span><span class="n">add_sequence</span><span class="p">(</span>
                <span class="s1">&#39;gs://hail-common/references/Homo_sapiens_assembly38.fasta.gz&#39;</span><span class="p">,</span>
                <span class="s1">&#39;gs://hail-common/references/Homo_sapiens_assembly38.fasta.fai&#39;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;GRCh37&#39;</span><span class="p">:</span>
            <span class="n">ref</span><span class="o">.</span><span class="n">add_sequence</span><span class="p">(</span>
                <span class="s1">&#39;gs://hail-common/references/human_g1k_v37.fasta.gz&#39;</span><span class="p">,</span>
                <span class="s1">&#39;gs://hail-common/references/human_g1k_v37.fasta.fai&#39;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No known location for the fasta/fai files for genome </span><span class="si">{ref.name}</span><span class="s1">. Only GRCh37 and GRCh38 are supported at this time.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Reference genome sequence already present. Ignoring add_reference_sequence.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ref</span></div>


<div class="viewcode-block" id="get_reference_genome"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.get_reference_genome">[docs]</a><span class="k">def</span> <span class="nf">get_reference_genome</span><span class="p">(</span>
        <span class="n">locus</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">IntervalExpression</span><span class="p">],</span>
        <span class="n">add_sequence</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">ReferenceGenome</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the reference genome associated with the input Locus expression</span>

<span class="sd">    :param locus: Input locus</span>
<span class="sd">    :param add_sequence: If set, the fasta sequence is added to the reference genome</span>
<span class="sd">    :return: Reference genome</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">locus</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">):</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">locus</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">reference_genome</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">locus</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">IntervalExpression</span><span class="p">))</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">locus</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">point_type</span><span class="o">.</span><span class="n">reference_genome</span>
    <span class="k">if</span> <span class="n">add_sequence</span><span class="p">:</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">add_reference_sequence</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ref</span></div>


<div class="viewcode-block" id="flip_base"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.flip_base">[docs]</a><span class="k">def</span> <span class="nf">flip_base</span><span class="p">(</span><span class="n">base</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the complement of a base</span>

<span class="sd">    :param base: Base to be flipped</span>
<span class="sd">    :return: Complement of input base</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">base</span><span class="p">))</span></div>


<div class="viewcode-block" id="reverse_complement_bases"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.reverse_complement_bases">[docs]</a><span class="k">def</span> <span class="nf">reverse_complement_bases</span><span class="p">(</span><span class="n">bases</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the reverse complement of a sequence</span>

<span class="sd">    :param bases: Sequence to be flipped</span>
<span class="sd">    :return: Reverse complement of input sequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">bases</span><span class="o">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">flip_base</span><span class="p">(</span><span class="n">bases</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_to_autosomes"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.filter_to_autosomes">[docs]</a><span class="k">def</span> <span class="nf">filter_to_autosomes</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters the Table or MatrixTable to autosomes only.</span>
<span class="sd">    This assumes that the input contains a field named `locus` of type Locus</span>

<span class="sd">    :param t: Input MT/HT</span>
<span class="sd">    :return:  MT/HT autosomes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reference</span> <span class="o">=</span> <span class="n">get_reference_genome</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">)</span>
    <span class="n">autosomes</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">parse_locus_interval</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{reference.contigs[0]}</span><span class="s1">-</span><span class="si">{reference.contigs[21]}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">reference_genome</span><span class="o">=</span><span class="n">reference</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="n">autosomes</span><span class="p">])</span></div>


<div class="viewcode-block" id="write_temp_gcs"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.write_temp_gcs">[docs]</a><span class="k">def</span> <span class="nf">write_temp_gcs</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span> <span class="n">gcs_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                   <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">temp_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">temp_path</span><span class="p">:</span>
        <span class="n">temp_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;/tmp_{uuid.uuid4()}.h&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">temp_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">read_matrix_table</span><span class="p">(</span><span class="n">temp_path</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">temp_path</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">gcs_path</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_sample_data"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.get_sample_data">[docs]</a><span class="k">def</span> <span class="nf">get_sample_data</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">],</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delim</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;|&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Hail devs hate this one simple py4j trick to speed up sample queries</span>

<span class="sd">    :param mt:</span>
<span class="sd">    :param fields:</span>
<span class="sd">    :param sep: Separator to use (tab usually fine)</span>
<span class="sd">    :param delim: Delimiter to use (pipe usually fine)</span>
<span class="sd">    :return: Sample data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">field_expr</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">field_expr</span> <span class="o">=</span> <span class="n">field_expr</span> <span class="o">+</span> <span class="s1">&#39;|&#39;</span> <span class="o">+</span> <span class="n">field</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="n">mt_agg</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">aggregate_cols</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mt_agg</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">aggregate</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delim</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mt_agg</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">field_expr</span><span class="p">),</span> <span class="n">sep</span><span class="p">))</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;null&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="pc_project"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.pc_project">[docs]</a><span class="k">def</span> <span class="nf">pc_project</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
        <span class="n">loadings_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
        <span class="n">loading_location</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;loadings&quot;</span><span class="p">,</span>
        <span class="n">af_location</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pca_af&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Projects samples in `mt` on pre-computed PCs.</span>

<span class="sd">    :param mt: MT containing the samples to project</span>
<span class="sd">    :param loadings_ht: HT containing the PCA loadings and allele frequencies used for the PCA</span>
<span class="sd">    :param loading_location: Location of expression for loadings in `loadings_ht`</span>
<span class="sd">    :param af_location: Location of expression for allele frequency in `loadings_ht`</span>
<span class="sd">    :return: Table with scores calculated from loadings in column `scores`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_variants</span> <span class="o">=</span> <span class="n">loadings_ht</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span>
        <span class="n">pca_loadings</span><span class="o">=</span><span class="n">loadings_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">row_key</span><span class="p">][</span><span class="n">loading_location</span><span class="p">],</span>
        <span class="n">pca_af</span><span class="o">=</span><span class="n">loadings_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">row_key</span><span class="p">][</span><span class="n">af_location</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">pca_loadings</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">pca_af</span><span class="p">)</span> <span class="o">&amp;</span>
                        <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">pca_af</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">pca_af</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">gt_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mt</span><span class="o">.</span><span class="n">pca_af</span><span class="p">)</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_variants</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mt</span><span class="o">.</span><span class="n">pca_af</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mt</span><span class="o">.</span><span class="n">pca_af</span><span class="p">))</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">scores</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">pca_loadings</span> <span class="o">*</span> <span class="n">gt_norm</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;scores&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="sample_pcs_uniformly"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.sample_pcs_uniformly">[docs]</a><span class="k">def</span> <span class="nf">sample_pcs_uniformly</span><span class="p">(</span><span class="n">scores_table</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">num_pcs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">num_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">num_per_bin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sample somewhat uniformly in num_pcs-dimensional PC space.</span>

<span class="sd">    Works by:</span>

<span class="sd">    1. Binning each PC axis into num_bins bins, creating an array of num_pcs with num_bins possible values (total of num_bins ^ num_pcs sectors)</span>
<span class="sd">    2. For each k-dimensional sector, take up to num_per_bin samples</span>

<span class="sd">    Max number of samples return is num_per_bin * num_bins ^ num_pcs, but in practice, typically much fewer (corners of PC space are sparse)</span>

<span class="sd">    Assumes your scores are in scores_table.scores (and sample stored in `s`)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="n">scores_table</span><span class="o">.</span><span class="n">aggregate</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">scores_table</span><span class="o">.</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pcs</span><span class="p">)])</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">max</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">]</span>
    <span class="n">ranges</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">r</span> <span class="o">/</span> <span class="n">num_bins</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">])</span>

    <span class="n">scores_table</span> <span class="o">=</span> <span class="n">scores_table</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">scores_bin</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_pcs</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span>
                                            <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">((</span><span class="n">scores_table</span><span class="o">.</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">ranges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">step</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">per_bin</span> <span class="o">=</span> <span class="n">scores_table</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">scores_table</span><span class="o">.</span><span class="n">scores_bin</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">scores_table</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">num_per_bin</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">per_bin</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="n">per_bin</span><span class="o">.</span><span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_low_conf_regions"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.filter_low_conf_regions">[docs]</a><span class="k">def</span> <span class="nf">filter_low_conf_regions</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span> <span class="n">filter_lcr</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">filter_decoy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">filter_segdup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">filter_exome_low_coverage_regions</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">high_conf_regions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters low-confidence regions</span>

<span class="sd">    :param mt: MatrixTable or Table to filter</span>
<span class="sd">    :param filter_lcr: Whether to filter LCR regions</span>
<span class="sd">    :param filter_decoy: Whether to filter decoy regions</span>
<span class="sd">    :param filter_segdup: Whether to filter Segdup regions</span>
<span class="sd">    :param filter_exome_low_coverage_regions: Whether to filter exome low confidence regions</span>
<span class="sd">    :param high_conf_regions: Paths to set of high confidence regions to restrict to (union of regions)</span>
<span class="sd">    :return: MatrixTable or Table with low confidence regions removed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">build</span> <span class="o">=</span> <span class="n">get_reference_genome</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">build</span> <span class="o">==</span> <span class="s2">&quot;GRCh37&quot;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">gnomad.resources.grch37.reference_data</span> <span class="k">as</span> <span class="nn">resources</span>
    <span class="k">elif</span> <span class="n">build</span> <span class="o">==</span> <span class="s2">&quot;GRCh38&quot;</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">gnomad.resources.grch38.reference_data</span> <span class="k">as</span> <span class="nn">resources</span>

    <span class="n">criteria</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">filter_lcr</span><span class="p">:</span>
        <span class="n">lcr</span> <span class="o">=</span> <span class="n">resources</span><span class="o">.</span><span class="n">lcr_intervals</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
        <span class="n">criteria</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">lcr</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">filter_decoy</span><span class="p">:</span>
        <span class="n">decoy</span> <span class="o">=</span> <span class="n">resources</span><span class="o">.</span><span class="n">decoy_intervals</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
        <span class="n">criteria</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">decoy</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">filter_segdup</span><span class="p">:</span>
        <span class="n">segdup</span> <span class="o">=</span> <span class="n">resources</span><span class="o">.</span><span class="n">seg_dup_intervals</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
        <span class="n">criteria</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">segdup</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">filter_exome_low_coverage_regions</span><span class="p">:</span>
        <span class="n">high_cov</span> <span class="o">=</span> <span class="n">resources</span><span class="o">.</span><span class="n">high_coverage_intervals</span><span class="o">.</span><span class="n">ht</span><span class="p">()</span>
        <span class="n">criteria</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">high_cov</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">high_conf_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">high_conf_regions</span><span class="p">:</span>
            <span class="n">region</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">import_locus_intervals</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
            <span class="n">criteria</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">region</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">criteria</span><span class="p">:</span>
        <span class="n">filter_criteria</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">iand</span><span class="p">,</span> <span class="n">criteria</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
            <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">filter_criteria</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">filter_criteria</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span></div>


<div class="viewcode-block" id="vep_context_ht_path"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.vep_context_ht_path">[docs]</a><span class="k">def</span> <span class="nf">vep_context_ht_path</span><span class="p">(</span><span class="n">ref</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;GRCh37&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VEP_REFERENCE_DATA</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">DataException</span><span class="p">(</span><span class="s2">&quot;Select reference as one of: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">VEP_REFERENCE_DATA</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
    <span class="k">return</span> <span class="n">VEP_REFERENCE_DATA</span><span class="p">[</span><span class="n">ref</span><span class="p">][</span><span class="s1">&#39;all_possible&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="vep_config_path"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.vep_config_path">[docs]</a><span class="k">def</span> <span class="nf">vep_config_path</span><span class="p">(</span><span class="n">ref</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;GRCh37&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">VEP_REFERENCE_DATA</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="n">DataException</span><span class="p">(</span><span class="s2">&quot;Select reference as one of: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">VEP_REFERENCE_DATA</span><span class="o">.</span><span class="n">keys</span><span class="p">())))</span>
    <span class="k">return</span> <span class="n">VEP_REFERENCE_DATA</span><span class="p">[</span><span class="n">ref</span><span class="p">][</span><span class="s1">&#39;vep_config&#39;</span><span class="p">]</span></div>


<div class="viewcode-block" id="vep_or_lookup_vep"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.vep_or_lookup_vep">[docs]</a><span class="k">def</span> <span class="nf">vep_or_lookup_vep</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">reference_vep_ht</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vep_config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    VEP a table, or lookup variants in a reference database</span>

<span class="sd">    :param ht: Input Table</span>
<span class="sd">    :param reference_vep_ht: A reference database with VEP annotations (must be in top-level `vep`)</span>
<span class="sd">    :param reference: If reference_vep_ht is not specified, find a suitable one in reference (if None, grabs from hl.default_reference)</span>
<span class="sd">    :param vep_config: vep_config to pass to hl.vep (if None, a suitable one for `reference` is chosen)</span>
<span class="sd">    :return: VEPped Table</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reference</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reference</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">default_reference</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">reference_vep_ht</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="n">possible_refs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;GRCh37&#39;</span><span class="p">,</span> <span class="s1">&#39;GRCh38&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reference</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_refs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;vep_or_lookup_vep got </span><span class="si">{reference}</span><span class="s1">. Expected one of {&quot;, &quot;.join(possible_refs)}&#39;</span><span class="p">)</span>

        <span class="n">reference_vep_ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">read_table</span><span class="p">(</span><span class="n">vep_context_ht_path</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">vep</span><span class="o">=</span><span class="n">reference_vep_ht</span><span class="p">[</span><span class="n">ht</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">vep</span><span class="p">)</span>

    <span class="n">vep_ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">vep</span><span class="p">))</span>
    <span class="n">revep_ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">vep</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">vep_config</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">vep_config</span> <span class="o">=</span> <span class="n">vep_config_path</span><span class="p">(</span><span class="n">reference</span><span class="p">)</span>

    <span class="n">revep_ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vep</span><span class="p">(</span><span class="n">revep_ht</span><span class="p">,</span> <span class="n">vep_config</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">vep_ht</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">revep_ht</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_most_severe_consequence_to_consequence"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.add_most_severe_consequence_to_consequence">[docs]</a><span class="k">def</span> <span class="nf">add_most_severe_consequence_to_consequence</span><span class="p">(</span><span class="n">tc</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add most_severe_consequence annotation to transcript consequences.</span>

<span class="sd">    This is for a given transcript, as there are often multiple annotations for a single transcript:</span>
<span class="sd">    e.g. splice_region_variant&amp;intron_variant -&gt; splice_region_variant</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.constants</span> <span class="kn">import</span> <span class="n">CSQ_ORDER</span>

    <span class="n">csqs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">CSQ_ORDER</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">tc</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">most_severe_consequence</span><span class="o">=</span><span class="n">csqs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">tc</span><span class="o">.</span><span class="n">consequence_terms</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="process_consequences"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.process_consequences">[docs]</a><span class="k">def</span> <span class="nf">process_consequences</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span> <span class="n">vep_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;vep&#39;</span><span class="p">,</span>
                         <span class="n">penalize_flags</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds most_severe_consequence (worst consequence for a transcript) into [vep_root].transcript_consequences,</span>
<span class="sd">    and worst_csq_by_gene, any_lof into [vep_root]</span>

<span class="sd">    :param mt: Input MT</span>
<span class="sd">    :param vep_root: Root for vep annotation (probably vep)</span>
<span class="sd">    :param penalize_flags: Whether to penalize LOFTEE flagged variants, or treat them as equal to HC</span>
<span class="sd">    :return: MT with better formatted consequences</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">.constants</span> <span class="kn">import</span> <span class="n">CSQ_ORDER</span>

    <span class="n">csqs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">CSQ_ORDER</span><span class="p">)</span>
    <span class="n">csq_dict</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">CSQ_ORDER</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">CSQ_ORDER</span><span class="p">)))))</span>

    <span class="k">def</span> <span class="nf">find_worst_transcript_consequence</span><span class="p">(</span><span class="n">tcl</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets worst transcript_consequence from an array of em</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flag_score</span> <span class="o">=</span> <span class="mi">500</span>
        <span class="n">no_flag_score</span> <span class="o">=</span> <span class="n">flag_score</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">penalize_flags</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">csq_dict</span><span class="p">[</span><span class="n">csqs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">tc</span><span class="o">.</span><span class="n">most_severe_consequence</span><span class="p">)]</span>

        <span class="n">tcl</span> <span class="o">=</span> <span class="n">tcl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">tc</span><span class="p">:</span> <span class="n">tc</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">csq_score</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">(</span><span class="n">missing_false</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">tc</span><span class="o">.</span><span class="n">lof</span> <span class="o">==</span> <span class="s1">&#39;HC&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">lof_flags</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="o">-</span> <span class="n">no_flag_score</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">tc</span><span class="o">.</span><span class="n">lof</span> <span class="o">==</span> <span class="s1">&#39;HC&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">lof_flags</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="o">-</span> <span class="n">flag_score</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">lof</span> <span class="o">==</span> <span class="s1">&#39;OS&#39;</span><span class="p">,</span> <span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">lof</span> <span class="o">==</span> <span class="s1">&#39;LC&#39;</span><span class="p">,</span> <span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">10</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">polyphen_prediction</span> <span class="o">==</span> <span class="s1">&#39;probably_damaging&#39;</span><span class="p">,</span> <span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">polyphen_prediction</span> <span class="o">==</span> <span class="s1">&#39;possibly_damaging&#39;</span><span class="p">,</span> <span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.25</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">tc</span><span class="o">.</span><span class="n">polyphen_prediction</span> <span class="o">==</span> <span class="s1">&#39;benign&#39;</span><span class="p">,</span> <span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">csq_score</span><span class="p">(</span><span class="n">tc</span><span class="p">))</span>
        <span class="p">))</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">tcl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">tcl</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">csq_score</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">transcript_csqs</span> <span class="o">=</span> <span class="n">mt</span><span class="p">[</span><span class="n">vep_root</span><span class="p">]</span><span class="o">.</span><span class="n">transcript_consequences</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">add_most_severe_consequence_to_consequence</span><span class="p">)</span>

    <span class="n">gene_dict</span> <span class="o">=</span> <span class="n">transcript_csqs</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="k">lambda</span> <span class="n">tc</span><span class="p">:</span> <span class="n">tc</span><span class="o">.</span><span class="n">gene_symbol</span><span class="p">)</span>
    <span class="n">worst_csq_gene</span> <span class="o">=</span> <span class="n">gene_dict</span><span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="n">find_worst_transcript_consequence</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="n">sorted_scores</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">worst_csq_gene</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tc</span><span class="p">:</span> <span class="n">tc</span><span class="o">.</span><span class="n">csq_score</span><span class="p">)</span>

    <span class="n">canonical</span> <span class="o">=</span> <span class="n">transcript_csqs</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">csq</span><span class="p">:</span> <span class="n">csq</span><span class="o">.</span><span class="n">canonical</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">gene_canonical_dict</span> <span class="o">=</span> <span class="n">canonical</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="k">lambda</span> <span class="n">tc</span><span class="p">:</span> <span class="n">tc</span><span class="o">.</span><span class="n">gene_symbol</span><span class="p">)</span>
    <span class="n">worst_csq_gene_canonical</span> <span class="o">=</span> <span class="n">gene_canonical_dict</span><span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="n">find_worst_transcript_consequence</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
    <span class="n">sorted_canonical_scores</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">worst_csq_gene_canonical</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tc</span><span class="p">:</span> <span class="n">tc</span><span class="o">.</span><span class="n">csq_score</span><span class="p">)</span>

    <span class="n">vep_data</span> <span class="o">=</span> <span class="n">mt</span><span class="p">[</span><span class="n">vep_root</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">transcript_consequences</span><span class="o">=</span><span class="n">transcript_csqs</span><span class="p">,</span>
                                     <span class="n">worst_consequence_term</span><span class="o">=</span><span class="n">csqs</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">transcript_csqs</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">csq</span><span class="p">:</span> <span class="n">csq</span><span class="o">.</span><span class="n">most_severe_consequence</span><span class="p">)</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">c</span><span class="p">)),</span>
                                     <span class="n">worst_csq_by_gene</span><span class="o">=</span><span class="n">sorted_scores</span><span class="p">,</span>
                                     <span class="n">worst_csq_for_variant</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">sorted_scores</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                                     <span class="n">worst_csq_by_gene_canonical</span><span class="o">=</span><span class="n">sorted_canonical_scores</span><span class="p">,</span>
                                     <span class="n">worst_csq_for_variant_canonical</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">sorted_canonical_scores</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_canonical_scores</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                     <span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">vep_root</span><span class="p">:</span> <span class="n">vep_data</span><span class="p">})</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="k">else</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">vep_root</span><span class="p">:</span> <span class="n">vep_data</span><span class="p">})</span></div>


<div class="viewcode-block" id="filter_vep_to_canonical_transcripts"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.filter_vep_to_canonical_transcripts">[docs]</a><span class="k">def</span> <span class="nf">filter_vep_to_canonical_transcripts</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
                                        <span class="n">vep_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;vep&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
    <span class="n">canonical</span> <span class="o">=</span> <span class="n">mt</span><span class="p">[</span><span class="n">vep_root</span><span class="p">]</span><span class="o">.</span><span class="n">transcript_consequences</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">csq</span><span class="p">:</span> <span class="n">csq</span><span class="o">.</span><span class="n">canonical</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">vep_data</span> <span class="o">=</span> <span class="n">mt</span><span class="p">[</span><span class="n">vep_root</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">transcript_consequences</span><span class="o">=</span><span class="n">canonical</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">vep_root</span><span class="p">:</span> <span class="n">vep_data</span><span class="p">})</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="k">else</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">vep_root</span><span class="p">:</span> <span class="n">vep_data</span><span class="p">})</span></div>


<div class="viewcode-block" id="filter_vep_to_synonymous_variants"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.filter_vep_to_synonymous_variants">[docs]</a><span class="k">def</span> <span class="nf">filter_vep_to_synonymous_variants</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
                                      <span class="n">vep_root</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;vep&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
    <span class="n">synonymous</span> <span class="o">=</span> <span class="n">mt</span><span class="p">[</span><span class="n">vep_root</span><span class="p">]</span><span class="o">.</span><span class="n">transcript_consequences</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">csq</span><span class="p">:</span> <span class="n">csq</span><span class="o">.</span><span class="n">most_severe_consequence</span> <span class="o">==</span> <span class="s2">&quot;synonymous_variant&quot;</span><span class="p">)</span>
    <span class="n">vep_data</span> <span class="o">=</span> <span class="n">mt</span><span class="p">[</span><span class="n">vep_root</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">transcript_consequences</span><span class="o">=</span><span class="n">synonymous</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">vep_root</span><span class="p">:</span> <span class="n">vep_data</span><span class="p">})</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="k">else</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">vep_root</span><span class="p">:</span> <span class="n">vep_data</span><span class="p">})</span></div>


<div class="viewcode-block" id="select_primitives_from_ht"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.select_primitives_from_ht">[docs]</a><span class="k">def</span> <span class="nf">select_primitives_from_ht</span><span class="p">(</span><span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select only primitive types (string, int, float, bool) from a Table.</span>
<span class="sd">    Particularly useful for exporting a Table.</span>

<span class="sd">    :param ht: Input Table</span>
<span class="sd">    :return: Table with only primitive types selected</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">row_value</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span>
                        <span class="n">v</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">{</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tbool</span><span class="p">}})</span></div>


<div class="viewcode-block" id="annotation_type_is_numeric"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.annotation_type_is_numeric">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, returns whether it is a numerical type or not.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type is numeric</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat32</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">)</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="annotation_type_in_vcf_info"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.annotation_type_in_vcf_info">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_in_vcf_info</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, returns whether that type can be natively exported to a VCF INFO field.</span>
<span class="sd">    Note types that aren&#39;t natively exportable to VCF will be converted to String on export.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type can be exported to VCF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tset</span><span class="p">)</span> <span class="ow">or</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tbool</span><span class="p">)</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="phase_by_transmission"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.phase_by_transmission">[docs]</a><span class="k">def</span> <span class="nf">phase_by_transmission</span><span class="p">(</span>
        <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
        <span class="n">alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
        <span class="n">proband_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
        <span class="n">father_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
        <span class="n">mother_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Phases genotype calls in a trio based allele transmission.</span>

<span class="sd">    In the phased calls returned, the order is as follows:</span>
<span class="sd">    * Proband: father_allele | mother_allele</span>
<span class="sd">    * Parents: transmitted_allele | untransmitted_allele</span>

<span class="sd">    Phasing of sex chromosomes:</span>
<span class="sd">    Sex chromosomes of male individuals should be haploid to be phased correctly.</span>
<span class="sd">    If `proband_call` is diploid on non-par regions of the sex chromosomes, it is assumed to be female.</span>

<span class="sd">    Returns `NA` when genotype calls cannot be phased.</span>
<span class="sd">    The following genotype calls combinations cannot be phased by transmission:</span>
<span class="sd">    1. One of the calls in the trio is missing</span>
<span class="sd">    2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation)</span>
<span class="sd">    3. All individuals of the trio are heterozygous for the same two alleles</span>
<span class="sd">    4. Father is diploid on non-PAR region of X or Y</span>
<span class="sd">    5. Proband is diploid on non-PAR region of Y</span>

<span class="sd">    In addition, individual phased genotype calls are returned as missing in the following situations:</span>
<span class="sd">    1. All mother genotype calls non-PAR region of Y</span>
<span class="sd">    2. Diploid father genotype calls on non-PAR region of X for a male proband (proband and mother are still phased as father doesn&#39;t participate in allele transmission)</span>

<span class="sd">    :param locus: Locus in the trio MatrixTable</span>
<span class="sd">    :param alleles: Alleles in the trio MatrixTable</span>
<span class="sd">    :param proband_call: Input proband genotype call</span>
<span class="sd">    :param father_call: Input father genotype call</span>
<span class="sd">    :param mother_call: Input mother genotype call</span>
<span class="sd">    :return: Array containing: phased proband call, phased father call, phased mother call</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">call_to_one_hot_alleles_array</span><span class="p">(</span><span class="n">call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span> <span class="n">alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the set of all different one-hot-encoded allele-vectors in a genotype call.</span>
<span class="sd">        It is returned as an ordered array where the first vector corresponds to the first allele,</span>
<span class="sd">        and the second vector (only present if het) the second allele.</span>

<span class="sd">        :param call: genotype</span>
<span class="sd">        :param alleles: Alleles at the site</span>
<span class="sd">        :return: Array of one-hot-encoded alleles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">call</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">alleles</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">alleles</span><span class="p">),</span>
            <span class="p">]),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">alleles</span><span class="p">)])</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">phase_parent_call</span><span class="p">(</span><span class="n">call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span> <span class="n">transmitted_allele_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a genotype and which allele was transmitted to the offspring, returns the parent phased genotype.</span>

<span class="sd">        :param call: Parent genotype</span>
<span class="sd">        :param transmitted_allele_index: index of transmitted allele (0 or 1)</span>
<span class="sd">        :return: Phased parent genotype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span>
            <span class="n">call</span><span class="p">[</span><span class="n">transmitted_allele_index</span><span class="p">],</span>
            <span class="n">call</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">transmitted_allele_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)],</span>
            <span class="n">phased</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">phase_diploid_proband</span><span class="p">(</span>
            <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
            <span class="n">alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
            <span class="n">proband_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
            <span class="n">father_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
            <span class="n">mother_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns phased genotype calls in the case of a diploid proband</span>
<span class="sd">        (autosomes, PAR regions of sex chromosomes or non-PAR regions of a female proband)</span>

<span class="sd">        :param locus: Locus in the trio MatrixTable</span>
<span class="sd">        :param alleles: Alleles in the trio MatrixTable</span>
<span class="sd">        :param proband_call: Input proband genotype call</span>
<span class="sd">        :param father_call: Input father genotype call</span>
<span class="sd">        :param mother_call: Input mother genotype call</span>
<span class="sd">        :return: Array containing: phased proband call, phased father call, phased mother call</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">proband_v</span> <span class="o">=</span> <span class="n">proband_call</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">alleles</span><span class="p">)</span>
        <span class="n">father_v</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">father_call</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">father_call</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">alleles</span><span class="p">)])),</span>
            <span class="n">call_to_one_hot_alleles_array</span><span class="p">(</span><span class="n">father_call</span><span class="p">,</span> <span class="n">alleles</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">mother_v</span> <span class="o">=</span> <span class="n">call_to_one_hot_alleles_array</span><span class="p">(</span><span class="n">mother_call</span><span class="p">,</span> <span class="n">alleles</span><span class="p">)</span>

        <span class="n">combinations</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatmap</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">zip_with_index</span><span class="p">(</span><span class="n">mother_v</span><span class="p">)</span>
                <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">proband_v</span><span class="p">)</span>
                <span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">zip_with_index</span><span class="p">(</span><span class="n">father_v</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">combinations</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">combinations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">father_call</span><span class="p">[</span><span class="n">combinations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">],</span> <span class="n">mother_call</span><span class="p">[</span><span class="n">combinations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">father_call</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">father_call</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">phase_parent_call</span><span class="p">(</span><span class="n">father_call</span><span class="p">,</span> <span class="n">combinations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">f</span><span class="p">)),</span>
                    <span class="n">phase_parent_call</span><span class="p">(</span><span class="n">mother_call</span><span class="p">,</span> <span class="n">combinations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
                <span class="p">]),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">phase_haploid_proband_x_nonpar</span><span class="p">(</span>
            <span class="n">proband_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
            <span class="n">father_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
            <span class="n">mother_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns phased genotype calls in the case of a haploid proband in the non-PAR region of X</span>

<span class="sd">        :param proband_call: Input proband genotype call</span>
<span class="sd">        :param father_call: Input father genotype call</span>
<span class="sd">        :param mother_call: Input mother genotype call</span>
<span class="sd">        :return: Array containing: phased proband call, phased father call, phased mother call</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">transmitted_allele</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">zip_with_index</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mother_call</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mother_call</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">proband_call</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">transmitted_allele</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">proband_call</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">father_call</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">father_call</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span>
                <span class="n">phase_parent_call</span><span class="p">(</span><span class="n">mother_call</span><span class="p">,</span> <span class="n">transmitted_allele</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">]),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">phase_y_nonpar</span><span class="p">(</span>
            <span class="n">proband_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
            <span class="n">father_call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns phased genotype calls in the non-PAR region of Y (requires both father and proband to be haploid to return phase)</span>

<span class="sd">        :param proband_call: Input proband genotype call</span>
<span class="sd">        :param father_call: Input father genotype call</span>
<span class="sd">        :return: Array containing: phased proband call, phased father call, phased mother call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">proband_call</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">father_call</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">father_call</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">proband_call</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">proband_call</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">father_call</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">)</span>
            <span class="p">]),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">proband_call</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">phase_haploid_proband_x_nonpar</span><span class="p">(</span><span class="n">proband_call</span><span class="p">,</span> <span class="n">father_call</span><span class="p">,</span> <span class="n">mother_call</span><span class="p">))</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span> <span class="n">phase_y_nonpar</span><span class="p">(</span><span class="n">proband_call</span><span class="p">,</span> <span class="n">father_call</span><span class="p">))</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">proband_call</span><span class="o">.</span><span class="n">is_diploid</span><span class="p">(),</span> <span class="n">phase_diploid_proband</span><span class="p">(</span><span class="n">locus</span><span class="p">,</span> <span class="n">alleles</span><span class="p">,</span> <span class="n">proband_call</span><span class="p">,</span> <span class="n">father_call</span><span class="p">,</span> <span class="n">mother_call</span><span class="p">))</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">)))</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="phase_trio_matrix_by_transmission"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.phase_trio_matrix_by_transmission">[docs]</a><span class="k">def</span> <span class="nf">phase_trio_matrix_by_transmission</span><span class="p">(</span><span class="n">tm</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">call_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;GT&#39;</span><span class="p">,</span> <span class="n">phased_call_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;PBT_GT&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a phased genoype entry to a trio MatrixTable based allele transmission in the trio.</span>
<span class="sd">    Uses only a `Call` field to phase and only phases when all 3 members of the trio are present and have a call.</span>

<span class="sd">    In the phased genotypes, the order is as follows:</span>
<span class="sd">    * Proband: father_allele | mother_allele</span>
<span class="sd">    * Parents: transmitted_allele | untransmitted_allele</span>

<span class="sd">    Phasing of sex chromosomes:</span>
<span class="sd">    Sex chromosomes of male individuals should be haploid to be phased correctly.</span>
<span class="sd">    If a proband is diploid on non-par regions of the sex chromosomes, it is assumed to be female.</span>

<span class="sd">    Genotypes that cannot be phased are set to `NA`.</span>
<span class="sd">    The following genotype calls combinations cannot be phased by transmission (all trio members phased calls set to missing):</span>
<span class="sd">    1. One of the calls in the trio is missing</span>
<span class="sd">    2. The proband genotype cannot be obtained from the parents alleles (Mendelian violation)</span>
<span class="sd">    3. All individuals of the trio are heterozygous for the same two alleles</span>
<span class="sd">    4. Father is diploid on non-PAR region of X or Y</span>
<span class="sd">    5. Proband is diploid on non-PAR region of Y</span>

<span class="sd">    In addition, individual phased genotype calls are returned as missing in the following situations:</span>
<span class="sd">    1. All mother genotype calls non-PAR region of Y</span>
<span class="sd">    2. Diploid father genotype calls on non-PAR region of X for a male proband (proband and mother are still phased as father doesn&#39;t participate in allele transmission)</span>


<span class="sd">    Typical usage::</span>

<span class="sd">        trio_matrix = hl.trio_matrix(mt, ped)</span>
<span class="sd">        phased_trio_matrix = phase_trio_matrix_by_transmission(trio_matrix)</span>

<span class="sd">    :param tm: Trio MatrixTable (entries should be a Struct with `proband_entry`, `mother_entry` and `father_entry` present)</span>
<span class="sd">    :param call_field: genotype field name to phase</span>
<span class="sd">    :param phased_call_field: name for the phased genotype field</span>
<span class="sd">    :return: trio MatrixTable entry with additional phased genotype field for each individual</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tm</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">annotate_entries</span><span class="p">(</span>
        <span class="n">__phased_GT</span><span class="o">=</span><span class="n">phase_by_transmission</span><span class="p">(</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">proband_entry</span><span class="p">[</span><span class="n">call_field</span><span class="p">],</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">father_entry</span><span class="p">[</span><span class="n">call_field</span><span class="p">],</span>
            <span class="n">tm</span><span class="o">.</span><span class="n">mother_entry</span><span class="p">[</span><span class="n">call_field</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">tm</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span>
        <span class="n">proband_entry</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="n">tm</span><span class="o">.</span><span class="n">proband_entry</span><span class="p">,</span>
            <span class="o">**</span><span class="p">{</span><span class="n">phased_call_field</span><span class="p">:</span> <span class="n">tm</span><span class="o">.</span><span class="n">__phased_GT</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="p">),</span>
        <span class="n">father_entry</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="n">tm</span><span class="o">.</span><span class="n">father_entry</span><span class="p">,</span>
            <span class="o">**</span><span class="p">{</span><span class="n">phased_call_field</span><span class="p">:</span> <span class="n">tm</span><span class="o">.</span><span class="n">__phased_GT</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span>
        <span class="p">),</span>
        <span class="n">mother_entry</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="n">tm</span><span class="o">.</span><span class="n">mother_entry</span><span class="p">,</span>
            <span class="o">**</span><span class="p">{</span><span class="n">phased_call_field</span><span class="p">:</span> <span class="n">tm</span><span class="o">.</span><span class="n">__phased_GT</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="explode_trio_matrix"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.explode_trio_matrix">[docs]</a><span class="k">def</span> <span class="nf">explode_trio_matrix</span><span class="p">(</span><span class="n">tm</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">col_keys</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a trio MatrixTable back into a sample MatrixTable.</span>

<span class="sd">    :param tm: Input trio MatrixTable</span>
<span class="sd">    :param col_keys: Column keys for the sample MatrixTable</span>
<span class="sd">    :return: Sample MatrixTable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tm</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span>
        <span class="n">__trio_entries</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tm</span><span class="o">.</span><span class="n">proband_entry</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">father_entry</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">mother_entry</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="n">tm</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">select_cols</span><span class="p">(</span>
        <span class="n">__trio_members</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">zip_with_index</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">tm</span><span class="o">.</span><span class="n">proband</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">father</span><span class="p">,</span> <span class="n">tm</span><span class="o">.</span><span class="n">mother</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="n">explode_cols</span><span class="p">(</span><span class="n">tm</span><span class="o">.</span><span class="n">__trio_members</span><span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span>
        <span class="o">**</span><span class="n">mt</span><span class="o">.</span><span class="n">__trio_entries</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">__trio_members</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">key_cols_by</span><span class="p">()</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_cols</span><span class="p">(</span><span class="o">**</span><span class="n">mt</span><span class="o">.</span><span class="n">__trio_members</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">col_keys</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">key_cols_by</span><span class="p">(</span><span class="o">*</span><span class="n">col_keys</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span></div>


<div class="viewcode-block" id="expand_pd_array_col"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.expand_pd_array_col">[docs]</a><span class="k">def</span> <span class="nf">expand_pd_array_col</span><span class="p">(</span>
        <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">array_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">num_out_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">out_cols_prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">out_1based_indexing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expands a Dataframe column containing an array into multiple columns.</span>

<span class="sd">    :param df: input dataframe</span>
<span class="sd">    :param array_col: Column containing the array</span>
<span class="sd">    :param num_out_cols: Number of output columns. If set, only the `n_out_cols` first elements of the array column are output.</span>
<span class="sd">                             If &lt;1, the number of output columns is equal to the length of the shortest array in `array_col`</span>
<span class="sd">    :param out_cols_prefix: Prefix for the output columns (uses `array_col` as the prefix unless set)</span>
<span class="sd">    :param out_1based_indexing: If set, the output column names indexes start at 1. Otherwise they start at 0.</span>
<span class="sd">    :return: dataframe with expanded columns</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">out_cols_prefix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">out_cols_prefix</span> <span class="o">=</span> <span class="n">array_col</span>

    <span class="k">if</span> <span class="n">num_out_cols</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">num_out_cols</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="n">array_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">()])</span>

    <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">{}{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out_cols_prefix</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">out_1based_indexing</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_out_cols</span><span class="p">)]</span>
    <span class="n">df</span><span class="p">[</span><span class="n">cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">array_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">tolist</span><span class="p">())[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_out_cols</span><span class="p">))]</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="assign_population_pcs"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.assign_population_pcs">[docs]</a><span class="k">def</span> <span class="nf">assign_population_pcs</span><span class="p">(</span>
        <span class="n">pop_pca_scores</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
        <span class="n">pc_cols</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
        <span class="n">known_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;known_pop&#39;</span><span class="p">,</span>
        <span class="n">fit</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># Type should be RandomForestClassifier but we do not want to import sklearn.RandomForestClassifier outside</span>
        <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
        <span class="n">prop_train</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span>
        <span class="n">n_estimators</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">min_prob</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span>
        <span class="n">output_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;pop&#39;</span><span class="p">,</span>
        <span class="n">missing_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;oth&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span> <span class="c1"># 2nd element of the tuple should be RandomForestClassifier but we do not want to import sklearn.RandomForestClassifier outside</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function uses a random forest model to assign population labels based on the results of PCA.</span>
<span class="sd">    Default values for model and assignment parameters are those used in gnomAD.</span>

<span class="sd">    As input, this function can either take:</span>

<span class="sd">    - A Hail Table (typically the output of `hwe_normalized_pca`). In this case,</span>
<span class="sd">        - `pc_cols` should be an ArrayExpression of Floats where each element is one of the PCs to use.</span>
<span class="sd">        - A Hail Table will be returned as output</span>
<span class="sd">    - A Pandas DataFrame. In this case:</span>
<span class="sd">        - Each PC should be in a separate column and `pc_cols` is the list of all the columns containing the PCs to use.</span>
<span class="sd">        - A pandas DataFrame is returned as output</span>

<span class="sd">    .. note::</span>

<span class="sd">        If you have a Pandas Dataframe and have all PCs as an array in a single column, the</span>
<span class="sd">        `expand_pd_array_col` can be used to expand this column into multiple `PC` columns.</span>

<span class="sd">    :param pop_pc_pd: Input Hail Table or Pandas Dataframe</span>
<span class="sd">    :param pc_cols: Columns storing the PCs to use</span>
<span class="sd">    :param known_col: Column storing the known population labels</span>
<span class="sd">    :param RandomForestClassifier fit: fit from a previously trained random forest model (i.e., the output from a previous RandomForestClassifier() call)</span>
<span class="sd">    :param seed: Random seed</span>
<span class="sd">    :param prop_train: Proportion of known data used for training</span>
<span class="sd">    :param n_estimators: Number of trees to use in the RF model</span>
<span class="sd">    :param min_prob: Minimum probability of belonging to a given population for the population to be set (otherwise set to `None`)</span>
<span class="sd">    :param output_col: Output column storing the assigned population</span>
<span class="sd">    :param missing_label: Label for samples for which the assignment probability is smaller than `min_prob`</span>
<span class="sd">    :return: Hail Table or Pandas Dataframe (depending on input) containing sample IDs and imputed population labels, trained random forest model</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="kn">import</span> <span class="n">RandomForestClassifier</span>
    <span class="n">hail_input</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pop_pca_scores</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">hail_input</span><span class="p">:</span>
        <span class="n">pop_pc_pd</span> <span class="o">=</span> <span class="n">pop_pca_scores</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">known_col</span><span class="p">,</span>
            <span class="n">pca_scores</span><span class="o">=</span><span class="n">pc_cols</span>
        <span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
        <span class="n">pop_pc_pd</span> <span class="o">=</span> <span class="n">expand_pd_array_col</span><span class="p">(</span><span class="n">pop_pc_pd</span><span class="p">,</span> <span class="s1">&#39;pca_scores&#39;</span><span class="p">,</span> <span class="n">out_cols_prefix</span><span class="o">=</span><span class="s1">&#39;PC&#39;</span><span class="p">)</span>
        <span class="n">pc_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">pop_pc_pd</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;PC&#39;</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pop_pc_pd</span> <span class="o">=</span> <span class="n">pop_pca_scores</span>

    <span class="n">train_data</span> <span class="o">=</span> <span class="n">pop_pc_pd</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">pop_pc_pd</span><span class="p">[</span><span class="n">known_col</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>

    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_data</span><span class="p">)</span>

    <span class="c1"># Split training data into subsamples for fitting and evaluating</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">fit</span><span class="p">:</span>
        <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">train_subsample_ridx</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">N</span> <span class="o">*</span> <span class="n">prop_train</span><span class="p">))</span>
        <span class="n">train_fit</span> <span class="o">=</span> <span class="n">train_data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">train_subsample_ridx</span><span class="p">]</span>
        <span class="n">fit_samples</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train_fit</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]]</span>
        <span class="n">evaluate_fit</span> <span class="o">=</span> <span class="n">train_data</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">train_data</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">fit_samples</span><span class="p">)]</span>

        <span class="c1"># Train RF</span>
        <span class="n">training_set_known_labels</span> <span class="o">=</span> <span class="n">train_fit</span><span class="p">[</span><span class="n">known_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">training_set_pcs</span> <span class="o">=</span> <span class="n">train_fit</span><span class="p">[</span><span class="n">pc_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">evaluation_set_pcs</span> <span class="o">=</span> <span class="n">evaluate_fit</span><span class="p">[</span><span class="n">pc_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="n">pop_clf</span> <span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span><span class="n">n_estimators</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
        <span class="n">pop_clf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">training_set_pcs</span><span class="p">,</span> <span class="n">training_set_known_labels</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Random forest feature importances are as follows: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pop_clf</span><span class="o">.</span><span class="n">feature_importances_</span><span class="p">))</span>

        <span class="c1"># Evaluate RF</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="n">pop_clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">evaluation_set_pcs</span><span class="p">)</span>
        <span class="n">error_rate</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">evaluate_fit</span><span class="p">[</span><span class="n">known_col</span><span class="p">]</span> <span class="o">==</span> <span class="n">predictions</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">predictions</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Estimated error rate for RF model is </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">error_rate</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pop_clf</span> <span class="o">=</span> <span class="n">fit</span>

    <span class="c1"># Classify data</span>
    <span class="n">pop_pc_pd</span><span class="p">[</span><span class="n">output_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pop_clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">pop_pc_pd</span><span class="p">[</span><span class="n">pc_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">pop_clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">pop_pc_pd</span><span class="p">[</span><span class="n">pc_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;prob_</span><span class="si">{p}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pop_clf</span><span class="o">.</span><span class="n">classes_</span><span class="p">])</span>
    <span class="n">pop_pc_pd</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pop_pc_pd</span><span class="p">,</span> <span class="n">probs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">probs</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">probs</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pop_pc_pd</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">probs</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_prob</span><span class="p">,</span> <span class="n">output_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing_label</span>
    <span class="n">pop_pc_pd</span> <span class="o">=</span> <span class="n">pop_pc_pd</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">pc_cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found the following sample count after population assignment: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{pop}</span><span class="s1">: </span><span class="si">{count}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">pop</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">Counter</span><span class="p">(</span><span class="n">pop_pc_pd</span><span class="p">[</span><span class="n">output_col</span><span class="p">])</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="p">))</span>

    <span class="k">if</span> <span class="n">hail_input</span><span class="p">:</span>
        <span class="n">pops_ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pop_pc_pd</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">pop_pca_scores</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>
        <span class="n">pops_ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
            <span class="n">assign_pops_from_pc_params</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="n">min_assignment_prob</span><span class="o">=</span><span class="n">min_prob</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">pops_ht</span><span class="p">,</span> <span class="n">pop_clf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pop_pc_pd</span><span class="p">,</span> <span class="n">pop_clf</span></div>


<div class="viewcode-block" id="merge_stats_counters_expr"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.merge_stats_counters_expr">[docs]</a><span class="k">def</span> <span class="nf">merge_stats_counters_expr</span><span class="p">(</span><span class="n">stats</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merges multiple stats counters, assuming that they were computed on non-overlapping data.</span>

<span class="sd">    Examples:</span>

<span class="sd">    - Merge stats computed on indel and snv separately</span>
<span class="sd">    - Merge stats computed on bi-allelic and multi-allelic variants separately</span>
<span class="sd">    - Merge stats computed on autosomes and sex chromosomes separately</span>

<span class="sd">    :param stats: An array of stats counters to merge</span>
<span class="sd">    :return: Merged stats Struct</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_stats</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This merges two stast counters together. It assumes that all stats counter fields are present in the struct.</span>

<span class="sd">        :param i: accumulator: struct with mean, n and variance</span>
<span class="sd">        :param j: new element: stats_struct -- needs to contain mean, n and variance</span>
<span class="sd">        :return: Accumulation over all elements: struct with mean, n and variance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">j</span><span class="o">.</span><span class="n">mean</span> <span class="o">-</span> <span class="n">i</span><span class="o">.</span><span class="n">mean</span>
        <span class="n">n_tot</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="o">.</span><span class="n">n</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="nb">min</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">min</span><span class="p">),</span>
            <span class="nb">max</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">max</span><span class="p">),</span>
            <span class="n">mean</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">mean</span> <span class="o">*</span> <span class="n">i</span><span class="o">.</span><span class="n">n</span> <span class="o">+</span> <span class="n">j</span><span class="o">.</span><span class="n">mean</span> <span class="o">*</span> <span class="n">j</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_tot</span><span class="p">,</span>
            <span class="n">variance</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">variance</span> <span class="o">+</span> <span class="n">j</span><span class="o">.</span><span class="n">variance</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta</span> <span class="o">*</span> <span class="n">delta</span> <span class="o">*</span> <span class="n">i</span><span class="o">.</span><span class="n">n</span> <span class="o">*</span> <span class="n">j</span><span class="o">.</span><span class="n">n</span><span class="p">)</span> <span class="o">/</span> <span class="n">n_tot</span><span class="p">,</span>
            <span class="n">n</span><span class="o">=</span><span class="n">n_tot</span><span class="p">,</span>
            <span class="nb">sum</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">sum</span> <span class="o">+</span> <span class="n">j</span><span class="o">.</span><span class="n">sum</span>
        <span class="p">)</span>

    <span class="c1"># Gather all metrics present in all stats counters</span>
    <span class="n">metrics</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">dropped_metrics</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">stat_expr</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="n">stat_expr_metrics</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stat_expr</span><span class="p">)</span>
        <span class="n">dropped_metrics</span> <span class="o">=</span> <span class="n">dropped_metrics</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">stat_expr_metrics</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">metrics</span><span class="p">))</span>
        <span class="n">metrics</span> <span class="o">=</span> <span class="n">metrics</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">stat_expr_metrics</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dropped_metrics</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following metrics will be dropped during stats counter merging as they do not appear in all counters: {&#39;, &#39;.join(dropped_metrics)}&quot;</span><span class="p">)</span>

    <span class="c1"># Because merging standard deviation requires having the mean and n,</span>
    <span class="c1"># check that they are also present if `stdev` is. Otherwise remove stdev</span>
    <span class="k">if</span> <span class="s1">&#39;stdev&#39;</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">:</span>
        <span class="n">missing_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_fields</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Cannot merge `stdev` from given stats counters since they are missing the following fields: {&quot;,&quot;.join(missing_fields)}&#39;</span><span class="p">)</span>
            <span class="n">metrics</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;stdev&#39;</span><span class="p">)</span>

    <span class="c1"># Create a struct with all possible stats for merging.</span>
    <span class="c1"># This step helps when folding because we can rely on the struct schema</span>
    <span class="c1"># Note that for intermediate merging, we compute the variance rather than the stdev</span>
    <span class="n">all_stats</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="nb">min</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">min</span> <span class="k">if</span> <span class="s1">&#39;min&#39;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="nb">max</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="s1">&#39;max&#39;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="n">mean</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span> <span class="k">if</span> <span class="s1">&#39;mean&#39;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="n">variance</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">stdev</span> <span class="o">*</span> <span class="n">x</span><span class="o">.</span><span class="n">stdev</span> <span class="k">if</span> <span class="s1">&#39;stdev&#39;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="n">n</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">n</span> <span class="k">if</span> <span class="s1">&#39;n&#39;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="nb">sum</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span> <span class="k">if</span> <span class="s1">&#39;sum&#39;</span> <span class="ow">in</span> <span class="n">metrics</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">)</span>
    <span class="p">))</span>

    <span class="c1"># Merge the stats</span>
    <span class="n">agg_stats</span> <span class="o">=</span> <span class="n">all_stats</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="n">add_stats</span><span class="p">,</span> <span class="n">all_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Return only the metrics that were present in all independent stats counters</span>
    <span class="c1"># If `stdev` is present, then compute it from the variance</span>
    <span class="k">return</span> <span class="n">agg_stats</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span><span class="n">metric</span><span class="p">:</span> <span class="n">agg_stats</span><span class="p">[</span><span class="n">metric</span><span class="p">]</span> <span class="k">if</span> <span class="n">metric</span> <span class="o">!=</span> <span class="s1">&#39;stdev&#39;</span> <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">agg_stats</span><span class="o">.</span><span class="n">variance</span><span class="p">)</span> <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span><span class="p">}</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bi_allelic_expr"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.bi_allelic_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_expr</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a boolean expression selecting bi-allelic sites only,</span>
<span class="sd">    accounting for whether the input MT/HT was split.</span>

<span class="sd">    :param t: Input HT/MT</span>
<span class="sd">    :return: Boolean expression selecting only bi-allelic sites</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="o">~</span><span class="n">t</span><span class="o">.</span><span class="n">was_split</span> <span class="k">if</span> <span class="s1">&#39;was_split&#39;</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span> <span class="k">else</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">))</span></div>


<div class="viewcode-block" id="bi_allelic_site_inbreeding_expr"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.bi_allelic_site_inbreeding_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_site_inbreeding_expr</span><span class="p">(</span><span class="n">call</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the site inbreeding coefficient as an expression to be computed on a MatrixTable.</span>

<span class="sd">    This is implemented based on the GATK InbreedingCoeff metric:</span>
<span class="sd">    https://software.broadinstitute.org/gatk/documentation/article.php?id=8032</span>

<span class="sd">    .. note::</span>

<span class="sd">        The computation is run based on the counts of alternate alleles and thus should only be run on bi-allelic sites.</span>

<span class="sd">    :param call: Expression giving the calls in the MT</span>
<span class="sd">    :return: Site inbreeding coefficient expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">inbreeding_coeff</span><span class="p">(</span><span class="n">gt_counts</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">DictExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
        <span class="n">inbreeding_coeff</span><span class="p">,</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">call</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">())</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="to_phred"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.to_phred">[docs]</a><span class="k">def</span> <span class="nf">to_phred</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the phred-scaled value of the linear-scale input</span>

<span class="sd">    :param linear_expr: input</span>
<span class="sd">    :return: Phred-scaled value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">10</span> <span class="o">*</span> <span class="n">hl</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">linear_expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="from_phred"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.from_phred">[docs]</a><span class="k">def</span> <span class="nf">from_phred</span><span class="p">(</span><span class="n">phred_score_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the linear-scale value of the phred-scaled input.</span>

<span class="sd">    :param phred_score_expr: phred-scaled value</span>
<span class="sd">    :return: linear-scale value of the phred-scaled input.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="p">(</span><span class="n">phred_score_expr</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span></div>


<div class="viewcode-block" id="fs_from_sb"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.fs_from_sb">[docs]</a><span class="k">def</span> <span class="nf">fs_from_sb</span><span class="p">(</span>
        <span class="n">sb</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">min_cell_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
        <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">min_p_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-320</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes `FS` (Fisher strand balance) annotation from  the `SB` (strand balance table) field.</span>
<span class="sd">    `FS` is the phred-scaled value of the double-sided Fisher exact test on strand balance.</span>

<span class="sd">    Using default values will have the same behavior as the GATK implementation, that is:</span>
<span class="sd">    - If sum(counts) &gt; 2*`min_cell_count` (default to GATK value of 200), they are normalized</span>
<span class="sd">    - If sum(counts) &lt; `min_count` (default to GATK value of 4), returns missing</span>
<span class="sd">    - Any p-value &lt; `min_p_value` (default to GATK value of 1e-320) is truncated to that value</span>

<span class="sd">    In addition to the default GATK behavior, setting `normalize` to `False` will perform a chi-squared test</span>
<span class="sd">    for large counts (&gt; `min_cell_count`) instead of normalizing the cell values.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can either take</span>
<span class="sd">        - an array of length containing the table counts: [ref fwd, ref rev, alt fwd, alt rev]</span>
<span class="sd">        - an array containig 2 arrays of length 2, containing the counts: [[ref fwd, ref rev], [alt fwd, alt rev]]</span>

<span class="sd">    GATK code here: https://github.com/broadinstitute/gatk/blob/master/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/FisherStrand.java</span>

<span class="sd">    :param sb: Count of ref/alt reads on each strand</span>
<span class="sd">    :param normalize: Whether to normalize counts is sum(counts) &gt; min_cell_count (normalize=True), or use a chi sq instead of FET (normalize=False)</span>
<span class="sd">    :param min_cell_count: Maximum count for performing a FET</span>
<span class="sd">    :param min_count: Minimum total count to output FS (otherwise null it output)</span>
<span class="sd">    :return: FS value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
            <span class="n">sb</span>
        <span class="p">)</span>

    <span class="n">sb_sum</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
        <span class="n">sb</span>
    <span class="p">)</span>

    <span class="c1"># Normalize table if counts get too large</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sb_sum</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
                <span class="n">sb_sum</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">min_cell_count</span><span class="p">,</span>
                <span class="n">sb</span><span class="p">,</span>
                <span class="n">sb</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">sb_sum</span> <span class="o">/</span> <span class="n">min_cell_count</span><span class="p">)))</span>
            <span class="p">),</span>
            <span class="n">sb</span><span class="p">,</span> <span class="n">sb_sum</span>
        <span class="p">)</span>

        <span class="c1"># FET</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">fisher_exact_test</span><span class="p">(</span>
                    <span class="n">fs_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">contingency_table_test</span><span class="p">(</span>
                    <span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">min_cell_count</span><span class="o">=</span><span class="n">min_cell_count</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Return null if counts &lt;= `min_count`</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">sb_sum</span> <span class="o">&gt;</span> <span class="n">min_count</span><span class="p">,</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs_expr</span><span class="p">)</span> <span class="c1"># Needed to avoid -0.0 values</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="vep_struct_to_csq"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.vep_struct_to_csq">[docs]</a><span class="k">def</span> <span class="nf">vep_struct_to_csq</span><span class="p">(</span>
        <span class="n">vep_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span>
        <span class="n">csq_fields</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Allele|Consequence|IMPACT|SYMBOL|Gene|Feature_type|Feature|BIOTYPE|EXON|INTRON|&quot;</span>
                          <span class="s2">&quot;HGVSc|HGVSp|cDNA_position|CDS_position|Protein_position|Amino_acids|Codons|&quot;</span>
                          <span class="s2">&quot;ALLELE_NUM|DISTANCE|STRAND|VARIANT_CLASS|MINIMISED|SYMBOL_SOURCE|HGNC_ID|CANONICAL|&quot;</span>
                          <span class="s2">&quot;TSL|APPRIS|CCDS|ENSP|SWISSPROT|TREMBL|UNIPARC|GENE_PHENO|SIFT|PolyPhen|DOMAINS|&quot;</span>
                          <span class="s2">&quot;HGVS_OFFSET|MOTIF_NAME|MOTIF_POS|HIGH_INF_POS|MOTIF_SCORE_CHANGE|LoF|LoF_filter|&quot;</span>
                          <span class="s2">&quot;LoF_flags|LoF_info&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a VEP Struct, returns and array of VEP VCF CSQ strings (one per consequence in the struct).</span>

<span class="sd">    The fields and their order will correspond to those passed in `csq_fields`, which corresponds to the</span>
<span class="sd">    VCF header that is required to interpret the VCF CSQ INFO field.</span>

<span class="sd">    Note that the order is flexible and that all fields that are in the default value are supported.</span>
<span class="sd">    These fields will be formatted in the same way that their VEP CSQ counterparts are.</span>

<span class="sd">    While other fields can be added if their name are the same as those in the struct. Their value will be the result of calling</span>
<span class="sd">    hl.str(), so it may differ from their usual VEP CSQ representation.</span>

<span class="sd">    :param vep_expr: The input VEP Struct</span>
<span class="sd">    :param csq_fields: The | delimited list of fields to include in the CSQ (in that order)</span>
<span class="sd">    :return: The corresponding CSQ strings</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_csq_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">csq_fields</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;|&quot;</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">get_csq_from_struct</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span> <span class="n">feature_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
        <span class="c1"># Most fields are 1-1, just lowercase</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="c1"># Add general exceptions</span>
        <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;allele&#39;</span><span class="p">:</span> <span class="n">element</span><span class="o">.</span><span class="n">variant_allele</span><span class="p">,</span>
            <span class="s1">&#39;consequence&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">consequence_terms</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;&amp;&#39;</span><span class="p">),</span>
            <span class="s1">&#39;feature_type&#39;</span><span class="p">:</span> <span class="n">feature_type</span><span class="p">,</span>
            <span class="s1">&#39;feature&#39;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">element</span><span class="o">.</span><span class="n">transcript_id</span> <span class="k">if</span> <span class="s1">&#39;transcript_id&#39;</span> <span class="ow">in</span> <span class="n">element</span> <span class="k">else</span>
                <span class="n">element</span><span class="o">.</span><span class="n">regulatory_feature_id</span> <span class="k">if</span> <span class="s1">&#39;regulatory_feature_id&#39;</span> <span class="ow">in</span> <span class="n">element</span> <span class="k">else</span>
                <span class="n">element</span><span class="o">.</span><span class="n">motif_feature_id</span> <span class="k">if</span> <span class="s1">&#39;motif_feature_id&#39;</span> <span class="ow">in</span> <span class="n">element</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="p">),</span>
            <span class="s1">&#39;variant_class&#39;</span><span class="p">:</span> <span class="n">vep_expr</span><span class="o">.</span><span class="n">variant_class</span>
        <span class="p">})</span>

        <span class="c1"># Add exception for transcripts</span>
        <span class="k">if</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;Transcript&#39;</span><span class="p">:</span>
            <span class="n">fields</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
                <span class="s1">&#39;canonical&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">canonical</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;YES&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                <span class="s1">&#39;ensp&#39;</span><span class="p">:</span> <span class="n">element</span><span class="o">.</span><span class="n">protein_id</span><span class="p">,</span>
                <span class="s1">&#39;gene&#39;</span><span class="p">:</span> <span class="n">element</span><span class="o">.</span><span class="n">gene_id</span><span class="p">,</span>
                <span class="s1">&#39;symbol&#39;</span><span class="p">:</span> <span class="n">element</span><span class="o">.</span><span class="n">gene_symbol</span><span class="p">,</span>
                <span class="s1">&#39;symbol_source&#39;</span><span class="p">:</span> <span class="n">element</span><span class="o">.</span><span class="n">gene_symbol_source</span><span class="p">,</span>
                <span class="s1">&#39;cdna_position&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">cdna_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">cdna_start</span> <span class="o">==</span> <span class="n">element</span><span class="o">.</span><span class="n">cdna_end</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">cdna_end</span><span class="p">)),</span>
                <span class="s1">&#39;cds_position&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">cds_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">cds_start</span> <span class="o">==</span> <span class="n">element</span><span class="o">.</span><span class="n">cds_end</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">cds_end</span><span class="p">)),</span>
                <span class="s1">&#39;protein_position&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">protein_start</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">protein_start</span> <span class="o">==</span> <span class="n">element</span><span class="o">.</span><span class="n">protein_end</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s2">&quot;-&quot;</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">protein_end</span><span class="p">)),</span>
                <span class="s1">&#39;sift&#39;</span><span class="p">:</span> <span class="n">element</span><span class="o">.</span><span class="n">sift_prediction</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">sift_score</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="s1">&#39;polyphen&#39;</span><span class="p">:</span> <span class="n">element</span><span class="o">.</span><span class="n">polyphen_prediction</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">polyphen_score</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span>
                <span class="s1">&#39;domains&#39;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">domains</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="n">d</span><span class="o">.</span><span class="n">db</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="s2">&quot;&amp;&quot;</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="k">elif</span> <span class="n">feature_type</span> <span class="o">==</span> <span class="s1">&#39;MotifFeature&#39;</span><span class="p">:</span>
            <span class="n">fields</span><span class="p">[</span><span class="s1">&#39;motif_score_change&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.3f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">element</span><span class="o">.</span><span class="n">motif_score_change</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)),</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">_csq_fields</span><span class="p">],</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>

    <span class="n">csq</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_array</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">feature_field</span><span class="p">,</span> <span class="n">feature_type</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;transcript_consequences&#39;</span><span class="p">,</span> <span class="s1">&#39;Transcript&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;regulatory_feature_consequences&#39;</span><span class="p">,</span> <span class="s1">&#39;RegulatoryFeature&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;motif_feature_consequences&#39;</span><span class="p">,</span> <span class="s1">&#39;MotifFeature&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;intergenic_consequences&#39;</span><span class="p">,</span> <span class="s1">&#39;Intergenic&#39;</span><span class="p">)]:</span>
        <span class="n">csq</span> <span class="o">=</span> <span class="n">csq</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span>
                <span class="n">vep_expr</span><span class="p">[</span><span class="n">feature_field</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">get_csq_from_struct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">feature_type</span><span class="o">=</span><span class="n">feature_type</span><span class="p">)</span>
                <span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">empty_array</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">csq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">csq</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_median_and_mad_expr"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.get_median_and_mad_expr">[docs]</a><span class="k">def</span> <span class="nf">get_median_and_mad_expr</span><span class="p">(</span>
        <span class="n">metric_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.4826</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the median and median absolute deviation (MAD) for the given expression.</span>
<span class="sd">    Note that the default value of k assumes normally distributed data.</span>

<span class="sd">    :param metric_expr: Expression to compute median and MAD for</span>
<span class="sd">    :param k: The scaling factor for MAD calculation. Default assumes normally distributed data.</span>
<span class="sd">    :return: Struct with median and MAD</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="n">median</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">mad</span><span class="o">=</span><span class="n">k</span> <span class="o">*</span> <span class="n">hl</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="p">),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">tuple</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">)]),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">metric_expr</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_array_element_type"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.get_array_element_type">[docs]</a><span class="k">def</span> <span class="nf">get_array_element_type</span><span class="p">(</span><span class="n">array_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">HailType</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the type of an array element.</span>

<span class="sd">    :param array_expr: The array expression to get the element type</span>
<span class="sd">    :return: Hail type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">array_expr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">element_type</span></div>


<div class="viewcode-block" id="ht_to_vcf_mt"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.ht_to_vcf_mt">[docs]</a><span class="k">def</span> <span class="nf">ht_to_vcf_mt</span><span class="p">(</span>
        <span class="n">info_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
        <span class="n">pipe_delimited_annotations</span>  <span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">INFO_VCF_AS_PIPE_DELIMITED_FIELDS</span>
 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a MT ready for vcf export from a HT. In particular, the following conversions are done:</span>
<span class="sd">    - All int64 are coerced to int32</span>
<span class="sd">    - Fields specified by `pipe_delimited_annotations` will be converted from arrays to pipe-delimited strings</span>

<span class="sd">    .. note::</span>

<span class="sd">        The MT returned has no cols.</span>

<span class="sd">    :param info_ht: Input HT</span>
<span class="sd">    :param pipe_delimited_annotations: List of info fields (they must be fields of the ht.info Struct)</span>
<span class="sd">    :return: MatrixTable ready for VCF export</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_pipe_expr</span><span class="p">(</span><span class="n">array_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">array_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="p">)),</span> <span class="s2">&quot;|&quot;</span><span class="p">)</span>

    <span class="c1"># Make sure the HT is keyed by locus, alleles</span>
    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s1">&#39;locus&#39;</span><span class="p">,</span> <span class="s1">&#39;alleles&#39;</span><span class="p">)</span>

    <span class="c1"># Convert int64 fields to int32 (int64 isn&#39;t supported by VCF)</span>
    <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">ft</span> <span class="ow">in</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">ft</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;int64&#39;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coercing field info.</span><span class="si">{f}</span><span class="s2"> from int64 to int32 for VCF output. Value will be capped at int32 max value.&quot;</span><span class="p">)</span>
            <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">f</span><span class="p">]))})</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ft</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;array&lt;int64&gt;&#39;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Coercing field info.</span><span class="si">{f}</span><span class="s2"> from array&lt;int64&gt; to array&lt;int32&gt; for VCF output. Array values will be capped at int32 max value.&quot;</span><span class="p">)</span>
            <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                <span class="n">info</span><span class="o">=</span><span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)))})</span>
            <span class="p">)</span>

    <span class="n">info_expr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Make sure to pipe-delimit fields that need to.</span>
    <span class="c1"># Note: the expr needs to be prefixed by &quot;|&quot; because GATK expect one value for the ref (always empty)</span>
    <span class="c1"># Note2: this doesn&#39;t produce the correct annotation for AS_SB_TABLE, but it is overwritten below</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">pipe_delimited_annotations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
            <span class="n">info_expr</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span> <span class="o">+</span> <span class="n">get_pipe_expr</span><span class="p">(</span><span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>

    <span class="c1"># Flatten SB if it is an array of arrays</span>
    <span class="k">if</span> <span class="s1">&#39;SB&#39;</span> <span class="ow">in</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">SB</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">info_expr</span><span class="p">[</span><span class="s1">&#39;SB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">SB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">SB</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="s1">&#39;AS_SB_TABLE&#39;</span> <span class="ow">in</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="p">:</span>
        <span class="n">info_expr</span><span class="p">[</span><span class="s1">&#39;AS_SB_TABLE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_pipe_expr</span><span class="p">(</span><span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)))</span>

    <span class="c1"># Annotate with new expression and add &#39;s&#39; empty string field required to cast HT to MT</span>
    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">info</span><span class="o">=</span><span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">info_expr</span><span class="p">),</span>
        <span class="n">s</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Create an MT with no cols so that we acn export to VCF</span>
    <span class="n">info_mt</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">to_matrix_table_row_major</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">],</span> <span class="n">entry_field_name</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">info_mt</span><span class="o">.</span><span class="n">filter_cols</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="sort_intervals"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.sort_intervals">[docs]</a><span class="k">def</span> <span class="nf">sort_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Interval</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sorts an array of intervals by:</span>
<span class="sd">    start contig, then start position, then end contig, then end position</span>

<span class="sd">    :param intervals: Intervals to sort</span>
<span class="sd">    :return: Sorted interval list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="n">intervals</span><span class="p">,</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">interval</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">reference_genome</span><span class="o">.</span><span class="n">contigs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span><span class="p">),</span>
            <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
            <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">reference_genome</span><span class="o">.</span><span class="n">contigs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">contig</span><span class="p">),</span>
            <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="union_intervals"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.union_intervals">[docs]</a><span class="k">def</span> <span class="nf">union_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Interval</span><span class="p">],</span> <span class="n">is_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a list with the union of all intervals in the input list by merging overlapping intervals.</span>

<span class="sd">    :param intervals: Intervals to merge</span>
<span class="sd">    :param is_sorted: If set, assumes intervals are already sorted, otherwise will sort.</span>
<span class="sd">    :return: List of merged intervals</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sorted_intervals</span> <span class="o">=</span> <span class="n">intervals</span> <span class="k">if</span> <span class="n">is_sorted</span> <span class="k">else</span> <span class="n">sort_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
    <span class="n">merged_intervals</span> <span class="o">=</span> <span class="n">sorted_intervals</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">sorted_intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
        <span class="k">if</span> <span class="n">merged_intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span> <span class="o">==</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">merged_intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span> <span class="o">&lt;</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">position</span> <span class="o">&lt;=</span> <span class="n">merged_intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span><span class="p">:</span>
                    <span class="n">merged_intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">Interval</span><span class="p">(</span><span class="n">merged_intervals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">merged_intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">merged_intervals</span></div>


<div class="viewcode-block" id="interval_length"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.interval_length">[docs]</a><span class="k">def</span> <span class="nf">interval_length</span><span class="p">(</span><span class="n">interval</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Interval</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the total number of bases in an Interval</span>

<span class="sd">    :param interval: Input interval</span>
<span class="sd">    :return: Total length of the interval</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span> <span class="o">!=</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">contig</span><span class="p">:</span>
        <span class="n">ref</span> <span class="o">=</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">reference_genome</span>
        <span class="k">return</span> <span class="p">(</span>
                <span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span><span class="p">)</span> <span class="o">-</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">position</span> <span class="o">+</span>
                <span class="nb">sum</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span> <span class="k">for</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">contigs</span><span class="p">[</span><span class="n">ref</span><span class="o">.</span><span class="n">contigs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ref</span><span class="o">.</span><span class="n">contigs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">contig</span><span class="p">)])</span> <span class="o">+</span>
                <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">position</span></div>


<div class="viewcode-block" id="rep_on_read"><a class="viewcode-back" href="../../../api_reference/utils/generic.html#gnomad.utils.generic.rep_on_read">[docs]</a><span class="k">def</span> <span class="nf">rep_on_read</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">n_partitions</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Repartitions a MatrixTable on read. Currently the best way to increase the number of partitions in a MatrixTable.</span>

<span class="sd">    :param path: Path to input MatrixTable</span>
<span class="sd">    :param n_partitions: Number of desired partitions</span>
<span class="sd">    :return: MatrixTable with the number of desired partitions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">read_matrix_table</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">_calculate_new_partitions</span><span class="p">(</span><span class="n">n_partitions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">read_matrix_table</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">_intervals</span><span class="o">=</span><span class="n">intervals</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>