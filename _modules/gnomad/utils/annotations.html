

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>gnomad.utils.annotations &mdash; gnomad master documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> gnomad
          

          
          </a>

          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>gnomad.utils.annotations</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for gnomad.utils.annotations</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>

<span class="kn">from</span> <span class="nn">gnomad.utils.generic</span> <span class="kn">import</span> <span class="n">filter_to_autosomes</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.gnomad_functions</span> <span class="kn">import</span> <span class="n">annotate_adj</span>

<span class="c1"># TODO: Use import below when relatedness PR goes in</span>
<span class="c1"># from gnomad.utils.relatedness import SIBLINGS</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;gnomad.utils&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="pop_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.pop_max_expr">[docs]</a><span class="k">def</span> <span class="nf">pop_max_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">pops_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an expression containing popmax: the frequency information about the population</span>
<span class="sd">    that has the highest AF from the populations provided in `freq_meta`,</span>
<span class="sd">    excluding those specified in `pops_to_exclude`.</span>
<span class="sd">    Only frequencies from adj populations are considered.</span>

<span class="sd">    This resulting struct contains the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - pop: str</span>

<span class="sd">    :param freq: ArrayExpression of Structs with fields [&#39;AC&#39;, &#39;AF&#39;, &#39;AN&#39;, &#39;homozygote_count&#39;]</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (as returned by annotate_freq)</span>
<span class="sd">    :param pops_to_exclude: Set of populations to skip for popmax calcluation</span>

<span class="sd">    :return: Popmax struct</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pops_to_exclude</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">pops_to_exclude</span><span class="p">)</span>
    <span class="n">popmax_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;pop&quot;</span><span class="p">})</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="n">freq_filtered</span> <span class="o">=</span> <span class="n">popmax_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">pop</span><span class="o">=</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">])</span>
    <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">sorted_freqs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">freq_filtered</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">AF</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">sorted_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="project_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.project_max_expr">[docs]</a><span class="k">def</span> <span class="nf">project_max_expr</span><span class="p">(</span>
    <span class="n">project_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">alleles_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">n_projects</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an expression that computes allele frequency information by project for the `n_projects` with the largest AF at this row.</span>
<span class="sd">    This return an array with one element per non-reference allele.</span>

<span class="sd">    Each of these elements is itself an array of structs with the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - project: str</span>

<span class="sd">    .. note::</span>

<span class="sd">        Only projects with AF &gt; 0 are returned.</span>
<span class="sd">        In case of ties, the project ordering is not guaranteed, and at most `n_projects` are returned.</span>

<span class="sd">    :param project_expr: column expression containing the project</span>
<span class="sd">    :param gt_expr: entry expression containing the genotype</span>
<span class="sd">    :param alleles_expr: row expression containing the alleles</span>
<span class="sd">    :param n_projects: Maximum number of projects to return for each row</span>
<span class="sd">    :return: projectmax expression</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_alleles</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles_expr</span><span class="p">)</span>

    <span class="c1"># compute call stats by  project</span>
    <span class="n">project_cs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">project_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">alleles_expr</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">n_alleles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Exclude monomorphic sites</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_alleles</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span>
                <span class="n">project_cs</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="c1"># filter to projects with AF &gt; 0</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">),</span>
                <span class="c1"># order the callstats computed by AF in decreasing order</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                <span class="c1"># take the n_projects projects with largest AF</span>
            <span class="p">)[:</span><span class="n">n_projects</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="c1"># add the project in the callstats struct</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="n">AC</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AF</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AN</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span>
                    <span class="n">homozygote_count</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">project</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="faf_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.faf_expr">[docs]</a><span class="k">def</span> <span class="nf">faf_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">pops_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">faf_thresholds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the filtering allele frequency (FAF) for each threshold specified in `faf_thresholds`.</span>
<span class="sd">    See http://cardiodb.org/allelefrequencyapp/ for more information.</span>

<span class="sd">    The FAF is computed for each of the following population stratification if found in `freq_meta`:</span>

<span class="sd">        - All samples, with adj criteria</span>
<span class="sd">        - For each population, with adj criteria</span>
<span class="sd">        - For all sex/population on the non-PAR regions of sex chromosomes (will be missing on autosomes and PAR regions of sex chromosomes)</span>

<span class="sd">    Each of the FAF entry is a struct with one entry per threshold specified in `faf_thresholds` of type float64.</span>

<span class="sd">    This returns a tuple with two expressions:</span>

<span class="sd">        1. An array of FAF expressions as described above</span>
<span class="sd">        2. An array of dict containing the metadata for each of the array elements, in the same format as that produced by `annotate_freq`.</span>

<span class="sd">    :param freq: ArrayExpression of call stats structs (typically generated by hl.agg.call_stats)</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (typically generated using annotate_freq)</span>
<span class="sd">    :param locus: locus</span>
<span class="sd">    :param pops_to_exclude: Set of populations to exclude from faf calculation (typically bottlenecked or consanguineous populations)</span>
<span class="sd">    :param faf_thresholds: List of FAF thresholds to compute</span>
<span class="sd">    :return: (FAF expression, FAF metadata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_pops_to_exclude</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">pops_to_exclude</span><span class="p">)</span> <span class="k">if</span> <span class="n">pops_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="p">)</span>
    <span class="n">faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sex_faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">))</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_pops_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;pop&quot;</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;faf{str(threshold)[2:]}&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_expr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="n">sex_faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                <span class="o">~</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="sa">f</span><span class="s2">&quot;faf{str(threshold)[2:]}&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                            <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
                    <span class="p">}</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_meta</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sex_faf_freq_indices</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">faf_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">faf_meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="qual_hist_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.qual_hist_expr">[docs]</a><span class="k">def</span> <span class="nf">qual_hist_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a struct expression with genotype quality histograms based on the arguments given (dp, gq, ad).</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `gt_expr` is provided, will return histograms for non-reference samples only as well as all samples.</span>
<span class="sd">        - `gt_expr` is required for the allele-balance histogram, as it is only computed on het samples.</span>
<span class="sd">        - If `adj_expr` is provided, additional histograms are computed using only adj samples.</span>

<span class="sd">    :param gt_expr: Entry expression containing genotype</span>
<span class="sd">    :param gq_expr: Entry expression containing genotype quality</span>
<span class="sd">    :param dp_expr: Entry expression containing depth</span>
<span class="sd">    :param ad_expr: Entry expression containing allelic depth (bi-allelic here)</span>
<span class="sd">    :param adj_expr: Entry expression containing adj (high quality) genotype status</span>
<span class="sd">    :return: Genotype quality histograms expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">gq_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;gq_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">gq_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dp_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;dp_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">dp_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gt_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{qual_hist_name}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{qual_hist_name}</span><span class="s2">_alt&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span> <span class="n">qual_hist_expr</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">ad_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;ab_hist_alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{qual_hist_name}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
            <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">adj_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{qual_hist_name}</span><span class="s2">_adj&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">adj_expr</span><span class="p">,</span> <span class="n">qual_hist_expr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">qual_hists</span><span class="p">)</span></div>


<div class="viewcode-block" id="age_hists_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.age_hists_expr">[docs]</a><span class="k">def</span> <span class="nf">age_hists_expr</span><span class="p">(</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">age_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span>
    <span class="n">lowest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">highest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a StructExpression with the age histograms for hets and homs.</span>

<span class="sd">    :param adj_expr: Entry expression containing whether a genotype is high quality (adj) or not</span>
<span class="sd">    :param gt_expr: Entry expression containing the genotype</span>
<span class="sd">    :param age_expr: Col expression containing the sample&#39;s age</span>
<span class="sd">    :param lowest_boundary: Lowest bin boundary (any younger sample will be binned in n_smaller)</span>
<span class="sd">    :param highest_boundary: Highest bin boundary (any older sample will be binned in n_larger)</span>
<span class="sd">    :param n_bins: Total number of bins</span>
<span class="sd">    :return: A struct with `age_hist_het` and `age_hist_hom`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">age_hist_het</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">age_hist_hom</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_hom_var</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="annotate_freq"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_freq">[docs]</a><span class="k">def</span> <span class="nf">annotate_freq</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subpop_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a row annotation `freq` to the input `mt` with stratified allele frequencies,</span>
<span class="sd">    and a global annotation `freq_meta` with metadata.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Currently this only supports bi-allelic sites.</span>
<span class="sd">        The input `mt` needs to have the following entry fields:</span>
<span class="sd">        - GT: a CallExpression containing the genotype</span>
<span class="sd">        - adj: a BooleanExpression containing whether the genotype is of high quality or not.</span>
<span class="sd">        All expressions arguments need to be expression on the input `mt`.</span>

<span class="sd">    .. rubric:: `freq` row annotation</span>

<span class="sd">    The `freq` row annotation is an Array of Struct, with each Struct containing the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>

<span class="sd">    Each element of the array corresponds to a stratification of the data, and the metadata about these annotations is</span>
<span class="sd">    stored in the globals.</span>

<span class="sd">    .. rubric:: Global `freq_meta` metadata annotation</span>

<span class="sd">    The global annotation `freq_meta` is added to the input `mt`. It is a list of dict.</span>
<span class="sd">    Each element of the list contains metadata on a frequency stratification and the index in the list corresponds</span>
<span class="sd">    to the index of that frequency stratification in the `freq` row annotation.</span>

<span class="sd">    .. rubric:: The `downsamplings` parameter</span>

<span class="sd">    If the `downsamplings` parameter is used, frequencies will be computed for all samples and by population</span>
<span class="sd">    (if `pop_expr` is specified) by downsampling the number of samples without replacement to each of the numbers specified in the</span>
<span class="sd">    `downsamplings` array, provided that there are enough samples in the dataset.</span>
<span class="sd">    In addition, if `pop_expr` is specified, a downsampling to each of the exact number of samples present in each population is added.</span>
<span class="sd">    Note that samples are randomly sampled only once, meaning that the lower downsamplings are subsets of the higher ones.</span>

<span class="sd">    :param mt: Input MatrixTable</span>
<span class="sd">    :param sex_expr: When specified, frequencies are stratified by sex. If `pop_expr` is also specified, then a pop/sex stratifiction is added.</span>
<span class="sd">    :param pop_expr: When specified, frequencies are stratified by population. If `sex_expr` is also specified, then a pop/sex stratifiction is added.</span>
<span class="sd">    :param subpop_expr: When specified, frequencies are stratified by sub-continental population. Note that `pop_expr` is required as well when using this option.</span>
<span class="sd">    :param additional_strata_expr: When specified, frequencies are stratified by the given additional strata found in the dict. This can e.g. be used to stratify by platform.</span>
<span class="sd">    :param downsamplings: When specified, frequencies are computed by downsampling the data to the number of samples given in the list. Note that if `pop_expr` is specified, downsamplings by population is also computed.</span>
<span class="sd">    :return: MatrixTable with `freq` annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">subpop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;annotate_freq requires pop_expr when using subpop_expr&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">additional_strata_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">additional_strata_expr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">additional_strata_expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sex_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">_freq_meta_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">sex</span><span class="o">=</span><span class="n">sex_expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">_freq_meta_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">pop</span><span class="o">=</span><span class="n">pop_expr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">subpop_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_freq_meta_expr</span> <span class="o">=</span> <span class="n">_freq_meta_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">subpop</span><span class="o">=</span><span class="n">subpop_expr</span><span class="p">)</span>

    <span class="c1"># Annotate cols with provided cuts</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">_freq_meta</span><span class="o">=</span><span class="n">_freq_meta_expr</span><span class="p">)</span>

    <span class="c1"># Get counters for sex, pop and subpop if set</span>
    <span class="n">cut_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">cut</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">[</span><span class="n">cut</span><span class="p">]),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">[</span><span class="n">cut</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">cut</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span>
        <span class="k">if</span> <span class="n">cut</span> <span class="o">!=</span> <span class="s2">&quot;subpop&quot;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="s2">&quot;subpop&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">:</span>
        <span class="n">cut_dict</span><span class="p">[</span><span class="s2">&quot;subpop&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">subpop</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">subpop</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">subpop</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="n">cut_data</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">aggregate_cols</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">cut_dict</span><span class="p">))</span>
    <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Create downsamplings if needed</span>
    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Add exact pop size downsampling if pops were provided</span>
        <span class="k">if</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">):</span>
            <span class="n">downsamplings</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">downsamplings</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
            <span class="p">)</span>  <span class="c1"># Add the pops values if not in yet</span>
            <span class="n">downsamplings</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">downsamplings</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found {len(downsamplings)} downsamplings: </span><span class="si">{downsamplings}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Shuffle the samples, then create a global index for downsampling</span>
        <span class="c1"># And a pop-index if pops were provided</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">rand_unif</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">downsampling_ht</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
        <span class="n">scan_expr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;global_idx&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">count</span><span class="p">()}</span>
        <span class="k">if</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">):</span>
            <span class="n">scan_expr</span><span class="p">[</span><span class="s2">&quot;pop_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">downsampling_ht</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="mi">0</span>
            <span class="p">)</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">scan_expr</span><span class="p">)</span>
        <span class="n">downsampling_ht</span> <span class="o">=</span> <span class="n">downsampling_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">scan_expr</span><span class="p">)</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">downsampling</span><span class="o">=</span><span class="n">downsampling_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">)</span>

        <span class="c1"># Create downsampled sample groups</span>
        <span class="n">sample_group_filters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;downsampling&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">ds</span><span class="p">),</span> <span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="s2">&quot;global&quot;</span><span class="p">},</span>
                    <span class="n">mt</span><span class="o">.</span><span class="n">downsampling</span><span class="o">.</span><span class="n">global_idx</span> <span class="o">&lt;</span> <span class="n">ds</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">downsamplings</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">):</span>
            <span class="n">sample_group_filters</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="p">(</span>
                        <span class="p">{</span><span class="s2">&quot;downsampling&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">ds</span><span class="p">),</span> <span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop</span><span class="p">},</span>
                        <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">downsampling</span><span class="o">.</span><span class="n">pop_idx</span> <span class="o">&lt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">pop</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">ds</span> <span class="ow">in</span> <span class="n">downsamplings</span>
                    <span class="k">for</span> <span class="n">pop</span><span class="p">,</span> <span class="n">pop_count</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">ds</span> <span class="o">&lt;=</span> <span class="n">pop_count</span>
                <span class="p">]</span>
            <span class="p">)</span>

    <span class="c1"># Add all desired strata, starting with the full set and ending with downsamplings (if any)</span>
    <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">[({},</span> <span class="kc">True</span><span class="p">)]</span>
        <span class="o">+</span> <span class="p">[({</span><span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop</span><span class="p">},</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">pop</span><span class="p">)</span> <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="p">{})]</span>
        <span class="o">+</span> <span class="p">[({</span><span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex</span><span class="p">},</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="n">sex</span><span class="p">)</span> <span class="k">for</span> <span class="n">sex</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">,</span> <span class="p">{})]</span>
        <span class="o">+</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">pop</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex</span><span class="p">},</span>
                <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">sex</span> <span class="o">==</span> <span class="n">sex</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">pop</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">sex</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">,</span> <span class="p">{})</span>
            <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span>
            <span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;subpop&quot;</span><span class="p">:</span> <span class="n">subpop</span><span class="o">.</span><span class="n">subpop</span><span class="p">,</span> <span class="s2">&quot;pop&quot;</span><span class="p">:</span> <span class="n">subpop</span><span class="o">.</span><span class="n">pop</span><span class="p">},</span>
                <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">pop</span> <span class="o">==</span> <span class="n">subpop</span><span class="o">.</span><span class="n">pop</span><span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="o">.</span><span class="n">subpop</span> <span class="o">==</span> <span class="n">subpop</span><span class="o">.</span><span class="n">subpop</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">subpop</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subpop&quot;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">]</span>
        <span class="o">+</span> <span class="p">[</span>
            <span class="p">({</span><span class="n">strata</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">s_value</span><span class="p">)},</span> <span class="n">mt</span><span class="o">.</span><span class="n">_freq_meta</span><span class="p">[</span><span class="n">strata</span><span class="p">]</span> <span class="o">==</span> <span class="n">s_value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">strata</span> <span class="ow">in</span> <span class="n">additional_strata_expr</span>
            <span class="k">for</span> <span class="n">s_value</span> <span class="ow">in</span> <span class="n">cut_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">strata</span><span class="p">,</span> <span class="p">{})</span>
        <span class="p">]</span>
        <span class="o">+</span> <span class="n">sample_group_filters</span>
    <span class="p">)</span>

    <span class="c1"># Annotate columns with group_membership</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">group_membership</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_group_filters</span><span class="p">])</span>

    <span class="c1"># Create and annotate global expression with meta information</span>
    <span class="n">freq_meta_expr</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">sample_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;adj&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_group</span> <span class="ow">in</span> <span class="n">sample_group_filters</span>
    <span class="p">]</span>
    <span class="n">freq_meta_expr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;raw&quot;</span><span class="p">})</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="n">freq_meta</span><span class="o">=</span><span class="n">freq_meta_expr</span><span class="p">)</span>

    <span class="c1"># Create frequency expression array from the sample groups</span>
    <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">group_membership</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mt</span><span class="o">.</span><span class="n">adj</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span>
        <span class="p">),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sample_group_filters</span><span class="p">)),</span>
    <span class="p">)</span>

    <span class="c1"># Insert raw as the second element of the array</span>
    <span class="n">freq_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">freq_expr</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
        <span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)])</span>
        <span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">freq_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="p">)</span>

    <span class="c1"># Select non-ref allele (assumes bi-allelic)</span>
    <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">freq_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">cs</span><span class="p">:</span> <span class="n">cs</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AC</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">AF</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span>
                <span class="mi">1</span>
            <span class="p">],</span>  <span class="c1"># TODO This is NA in case AC and AN are 0 -- should we set it to 0?</span>
            <span class="n">homozygote_count</span><span class="o">=</span><span class="n">cs</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Return MT with freq row annotation</span>
    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq_expr</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;_freq_meta&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_lowqual_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_lowqual_expr">[docs]</a><span class="k">def</span> <span class="nf">get_lowqual_expr</span><span class="p">(</span>
    <span class="n">alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">qual_approx_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">],</span>
    <span class="n">snv_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">snv_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>  <span class="c1"># 1/1000</span>
    <span class="n">indel_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">indel_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>  <span class="c1"># 1/8,000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes lowqual threshold expression for either split or unsplit alleles based on QUALapprox or AS_QUALapprox</span>

<span class="sd">    .. note::</span>

<span class="sd">        This lowqual annotation differs from the GATK LowQual filter. GATK uses the SNV prior if the site has any SNV</span>
<span class="sd">        so that SNVs are not penalized if there are also indels at those sites. This implementation will use the indel</span>
<span class="sd">        threshold for indels and the SNV threshold for the SNVs therefore excluding more indels than the GATK filter.</span>

<span class="sd">    :param alleles: Array of alleles</span>
<span class="sd">    :param qual_approx_expr: QUALapprox or AS_QUALapprox</span>
<span class="sd">    :param snv_phred_threshold: Phred-scaled SNV &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param snv_phred_het_prior: Phred-scaled SNV heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :param indel_phred_threshold: Phred-scaled indel &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param indel_phred_het_prior: Phred-scaled indel heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :return: lowqual expression (BooleanExpression if `qual_approx_expr`is Numeric, Array[BooleanExpression] if `qual_approx_expr` is ArrayNumeric)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">low_qual_expr</span><span class="p">(</span>
        <span class="n">ref</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
        <span class="n">alt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
        <span class="n">qual_approx</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">alt</span><span class="p">),</span>
            <span class="n">qual_approx</span> <span class="o">&lt;</span> <span class="n">snv_phred_threshold</span> <span class="o">+</span> <span class="n">snv_phred_het_prior</span><span class="p">,</span>
            <span class="n">qual_approx</span> <span class="o">&lt;</span> <span class="n">indel_phred_threshold</span> <span class="o">+</span> <span class="n">indel_phred_het_prior</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qual_approx_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">low_qual_expr</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span> <span class="n">qual_approx_expr</span><span class="p">[</span><span class="n">ai</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">low_qual_expr</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qual_approx_expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="generate_trio_stats_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.generate_trio_stats_expr">[docs]</a><span class="k">def</span> <span class="nf">generate_trio_stats_expr</span><span class="p">(</span>
    <span class="n">trio_mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">transmitted_strata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="n">de_novo_strata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="n">ac_strata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="n">proband_is_female_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a row-wise expression containing the following counts:</span>

<span class="sd">        - Number of alleles in het parents transmitted to the proband</span>
<span class="sd">        - Number of alleles in het parents not transmitted to the proband</span>
<span class="sd">        - Number of de novo mutations</span>
<span class="sd">        - Parent allele count</span>
<span class="sd">        - Proband allele count</span>

<span class="sd">    Transmission and de novo mutation metrics and allele counts can be stratified using additional filters.</span>
<span class="sd">    `transmitted_strata`, `de_novo_strata`, and `ac_strata` all expect a dictionary of filtering expressions keyed</span>
<span class="sd">    by their desired suffix to append for labeling. The default will perform counts using all genotypes and append</span>
<span class="sd">    &#39;raw&#39; to the label.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Expects that `mt` is dense if dealing with a sparse MT `hl.experimental.densify` must be run first.</span>

<span class="sd">    :param trio_mt: A trio standard trio MT (with the format as produced by hail.methods.trio_matrix)</span>
<span class="sd">    :param transmitted_strata: Strata for the transmission counts</span>
<span class="sd">    :param de_novo_strata: Strata for the de novo counts</span>
<span class="sd">    :param ac_strata: Strata for the parent and child allele counts</span>
<span class="sd">    :param proband_is_female_expr: An optional expression giving the sex the proband. If not given, DNMs are only computed for autosomes.</span>
<span class="sd">    :return: An expression with the counts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Create map for transmitted, untransmitted and DNM</span>
    <span class="n">hom_ref</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">het</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">hom_var</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="n">auto_or_par</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">hemi_x</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">hemi_y</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">trans_config_counts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c1"># kid, dad, mom, copy -&gt; t, u</span>
        <span class="p">(</span><span class="n">hom_ref</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_ref</span><span class="p">,</span> <span class="n">hom_ref</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_ref</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hom_ref</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">het</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">het</span><span class="p">,</span> <span class="n">hom_ref</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="n">het</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hom_ref</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="n">het</span><span class="p">,</span> <span class="n">hom_var</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">het</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hom_var</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_var</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_var</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hom_var</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_var</span><span class="p">,</span> <span class="n">hom_var</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">auto_or_par</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_ref</span><span class="p">,</span> <span class="n">hom_ref</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hemi_x</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_ref</span><span class="p">,</span> <span class="n">hom_var</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hemi_x</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_var</span><span class="p">,</span> <span class="n">hom_ref</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hemi_x</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">(</span><span class="n">hom_var</span><span class="p">,</span> <span class="n">hom_var</span><span class="p">,</span> <span class="n">het</span><span class="p">,</span> <span class="n">hemi_x</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="n">trans_count_map</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">trans_config_counts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_copy_state</span><span class="p">(</span><span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to go from LocusExpression to a copy-state int for indexing into the</span>
<span class="sd">        trans_count_map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span> <span class="n">auto_or_par</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">(),</span> <span class="n">hemi_x</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span> <span class="n">hemi_y</span><span class="p">)</span>
            <span class="o">.</span><span class="n">or_missing</span><span class="p">()</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_dnm</span><span class="p">(</span>
        <span class="n">proband_gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
        <span class="n">father_gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
        <span class="n">mother_gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
        <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
        <span class="n">proband_is_female</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to get whether a given genotype combination is a DNM at a given locus with a given proband sex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">proband_is_female</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Since no proband sex expression was given to generate_trio_stats_expr, only DNMs in autosomes will be counted.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                <span class="n">locus</span><span class="o">.</span><span class="n">in_autosome</span><span class="p">(),</span>
                <span class="n">proband_gt</span><span class="o">.</span><span class="n">is_het</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">father_gt</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">mother_gt</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span>
            <span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span><span class="n">proband_is_female</span> <span class="o">&amp;</span> <span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()),</span>
            <span class="n">proband_gt</span><span class="o">.</span><span class="n">is_het</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">father_gt</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">mother_gt</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                <span class="o">~</span><span class="n">proband_is_female</span><span class="p">,</span> <span class="n">proband_gt</span><span class="o">.</span><span class="n">is_hom_var</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">father_gt</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">()</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ac_an_parent_child_count</span><span class="p">(</span>
        <span class="n">proband_gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
        <span class="n">father_gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
        <span class="n">mother_gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to get AC and AN for parents and children</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ac_parent_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="n">father_gt</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">()</span> <span class="o">+</span> <span class="n">mother_gt</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">an_parent_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">father_gt</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mother_gt</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">ac_child_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">proband_gt</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">())</span>
        <span class="n">an_child_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">proband_gt</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;ac_parents&quot;</span><span class="p">:</span> <span class="n">ac_parent_expr</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;an_parents&quot;</span><span class="p">:</span> <span class="n">an_parent_expr</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;ac_children&quot;</span><span class="p">:</span> <span class="n">ac_child_expr</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;an_children&quot;</span><span class="p">:</span> <span class="n">an_child_expr</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># Create transmission counters</span>
    <span class="n">trio_stats</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{name2}</span><span class="s2">_</span><span class="si">{name}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">trio_mt</span><span class="o">.</span><span class="n">proband_entry</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">expr</span><span class="p">,</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="n">trans_count_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                        <span class="p">(</span>
                            <span class="n">trio_mt</span><span class="o">.</span><span class="n">proband_entry</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">(),</span>
                            <span class="n">trio_mt</span><span class="o">.</span><span class="n">father_entry</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">(),</span>
                            <span class="n">trio_mt</span><span class="o">.</span><span class="n">mother_entry</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">(),</span>
                            <span class="n">_get_copy_state</span><span class="p">(</span><span class="n">trio_mt</span><span class="o">.</span><span class="n">locus</span><span class="p">),</span>
                        <span class="p">),</span>
                        <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="p">)[</span><span class="n">i</span><span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">transmitted_strata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;n_transmitted&quot;</span><span class="p">,</span> <span class="s2">&quot;n_untransmitted&quot;</span><span class="p">])</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="c1"># Create de novo counters</span>
    <span class="n">trio_stats</span> <span class="o">=</span> <span class="n">trio_stats</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;n_de_novos_</span><span class="si">{name}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">_is_dnm</span><span class="p">(</span>
                    <span class="n">trio_mt</span><span class="o">.</span><span class="n">proband_entry</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
                    <span class="n">trio_mt</span><span class="o">.</span><span class="n">father_entry</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
                    <span class="n">trio_mt</span><span class="o">.</span><span class="n">mother_entry</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
                    <span class="n">trio_mt</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span>
                    <span class="n">proband_is_female_expr</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="o">&amp;</span> <span class="n">expr</span><span class="p">,</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">de_novo_strata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="n">trio_stats</span> <span class="o">=</span> <span class="n">trio_stats</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{name2}</span><span class="s2">_</span><span class="si">{name}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">expr</span><span class="p">,</span>
                <span class="n">_ac_an_parent_child_count</span><span class="p">(</span>
                    <span class="n">trio_mt</span><span class="o">.</span><span class="n">proband_entry</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
                    <span class="n">trio_mt</span><span class="o">.</span><span class="n">father_entry</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
                    <span class="n">trio_mt</span><span class="o">.</span><span class="n">mother_entry</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
                <span class="p">)[</span><span class="n">name2</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">ac_strata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name2</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;ac_parents&quot;</span><span class="p">,</span> <span class="s2">&quot;an_parents&quot;</span><span class="p">,</span> <span class="s2">&quot;ac_children&quot;</span><span class="p">,</span> <span class="s2">&quot;an_children&quot;</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">trio_stats</span></div>


<div class="viewcode-block" id="filter_mt_to_trios"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.filter_mt_to_trios">[docs]</a><span class="k">def</span> <span class="nf">filter_mt_to_trios</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">fam_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filters a MatrixTable to a set of trios in `fam_ht`, filters to autosomes, and annotates with adj.</span>

<span class="sd">    :param mt: A Matrix Table to filter to only trios</span>
<span class="sd">    :param fam_ht: A Table of trios to filter to, loaded using `hl.import_fam`</span>
<span class="sd">    :return: A MT filtered to trios and adj annotated</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Filter MT to samples present in any of the trios</span>
    <span class="n">fam_ht</span> <span class="o">=</span> <span class="n">fam_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">fam_members</span><span class="o">=</span><span class="p">[</span><span class="n">fam_ht</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">fam_ht</span><span class="o">.</span><span class="n">pat_id</span><span class="p">,</span> <span class="n">fam_ht</span><span class="o">.</span><span class="n">mat_id</span><span class="p">])</span>
    <span class="n">fam_ht</span> <span class="o">=</span> <span class="n">fam_ht</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;fam_members&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
    <span class="n">fam_ht</span> <span class="o">=</span> <span class="n">fam_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_cols</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">fam_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">]))</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">filter_to_autosomes</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">annotate_adj</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span></div>


<div class="viewcode-block" id="default_generate_trio_stats"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.default_generate_trio_stats">[docs]</a><span class="k">def</span> <span class="nf">default_generate_trio_stats</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Default function to run `generate_trio_stats_expr` to get trio stats stratified by raw and adj</span>

<span class="sd">    .. note::</span>

<span class="sd">        Expects that `mt` is it a trio matrix table that was annotated with adj and if dealing with</span>
<span class="sd">        a sparse MT `hl.experimental.densify` must be run first.</span>

<span class="sd">    :param mt: A Trio Matrix Table returned from `hl.trio_matrix`. Must be dense</span>
<span class="sd">    :return: Table with trio stats</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generating trio stats using {mt.count_cols()} trios.&quot;</span><span class="p">)</span>
    <span class="n">trio_adj</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">proband_entry</span><span class="o">.</span><span class="n">adj</span> <span class="o">&amp;</span> <span class="n">mt</span><span class="o">.</span><span class="n">father_entry</span><span class="o">.</span><span class="n">adj</span> <span class="o">&amp;</span> <span class="n">mt</span><span class="o">.</span><span class="n">mother_entry</span><span class="o">.</span><span class="n">adj</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span>
        <span class="o">**</span><span class="n">generate_trio_stats_expr</span><span class="p">(</span>
            <span class="n">mt</span><span class="p">,</span>
            <span class="n">transmitted_strata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;adj&quot;</span><span class="p">:</span> <span class="n">trio_adj</span><span class="p">},</span>
            <span class="n">de_novo_strata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;adj&quot;</span><span class="p">:</span> <span class="n">trio_adj</span><span class="p">},</span>
            <span class="n">ac_strata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;adj&quot;</span><span class="p">:</span> <span class="n">trio_adj</span><span class="p">},</span>
            <span class="n">proband_is_female_expr</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">is_female</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="generate_sib_stats_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.generate_sib_stats_expr">[docs]</a><span class="k">def</span> <span class="nf">generate_sib_stats_expr</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sib_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">i_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span>
    <span class="n">j_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;j&quot;</span><span class="p">,</span>
    <span class="n">strata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
    <span class="n">is_female</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates a row-wise expression containing the number of alternate alleles in common between sibling pairs.</span>

<span class="sd">    The sibling sharing counts can be stratified using additional filters using `stata`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function expects that the `mt` has either been split or filtered to only bi-allelics</span>
<span class="sd">        If a sample has multiple sibling pairs, only one pair will be counted</span>

<span class="sd">    :param mt: Input matrix table</span>
<span class="sd">    :param sib_ht: Table defining sibling pairs with one sample in a col (`i_col`) and the second in another col (`j_col`)</span>
<span class="sd">    :param i_col: Column containing the 1st sample of the pair in the relationship table</span>
<span class="sd">    :param j_col: Column containing the 2nd sample of the pair in the relationship table</span>
<span class="sd">    :param strata: Dict with additional strata to use when computing shared sibling variant counts</span>
<span class="sd">    :param is_female: An optional column in mt giving the sample sex. If not given, counts are only computed for autosomes.</span>
<span class="sd">    :return: A Table with the sibling shared variant counts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">get_alt_count</span><span class="p">(</span><span class="n">locus</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="n">is_female</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to calculate alt allele count with sex info if present</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">is_female</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome</span><span class="p">(),</span> <span class="n">gt</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">())</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span> <span class="n">gt</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">())</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="o">~</span><span class="n">is_female</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">gt</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">()),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">is_female</span> <span class="o">&amp;</span> <span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">is_female</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Since no sex expression was given to generate_sib_stats_expr, only variants in autosomes will be counted.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># If a sample is in sib_ht more than one time, keep only one of the sibling pairs</span>
    <span class="c1"># First filter to only samples found in mt to keep as many pairs as possible</span>
    <span class="n">s_to_keep</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">aggregate_cols</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect_as_set</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">s</span><span class="p">),</span> <span class="n">_localize</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">s_to_keep</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">sib_ht</span><span class="p">[</span><span class="n">i_col</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">s_to_keep</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">sib_ht</span><span class="p">[</span><span class="n">j_col</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">add_index</span><span class="p">(</span><span class="s2">&quot;sib_idx&quot;</span><span class="p">)</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">sibs</span><span class="o">=</span><span class="p">[</span><span class="n">sib_ht</span><span class="p">[</span><span class="n">i_col</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">sib_ht</span><span class="p">[</span><span class="n">j_col</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;sibs&quot;</span><span class="p">)</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;sibs&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">sib_idx</span><span class="o">=</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">sib_ht</span><span class="o">.</span><span class="n">sib_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ordering</span><span class="o">=</span><span class="n">sib_ht</span><span class="o">.</span><span class="n">sib_idx</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">)</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">sib_ht</span><span class="o">.</span><span class="n">sib_idx</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">sibs</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">sib_ht</span><span class="o">.</span><span class="n">sibs</span><span class="p">))</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">sib_ht</span><span class="o">.</span><span class="n">sibs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Generating sibling variant sharing counts using {sib_ht.count()} pairs.&quot;</span>
    <span class="p">)</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;sibs&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;sibs&quot;</span><span class="p">)[</span><span class="n">mt</span><span class="o">.</span><span class="n">s</span><span class="p">]</span>

    <span class="c1"># Create sibling sharing counters</span>
    <span class="n">sib_stats</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;n_sib_shared_variants_</span><span class="si">{name}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="n">expr</span><span class="p">,</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
                        <span class="n">sib_ht</span><span class="o">.</span><span class="n">sib_idx</span><span class="p">,</span>
                        <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">))</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">get_alt_count</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">is_female</span><span class="p">)),</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">strata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="n">sib_stats</span> <span class="o">=</span> <span class="n">sib_stats</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;ac_sibs_</span><span class="si">{name}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">expr</span> <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sib_ht</span><span class="o">.</span><span class="n">sib_idx</span><span class="p">),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">GT</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">())</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">strata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">sib_stats</span></div>


<div class="viewcode-block" id="default_generate_sib_stats"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.default_generate_sib_stats">[docs]</a><span class="k">def</span> <span class="nf">default_generate_sib_stats</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">relatedness_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">sex_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">i_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span><span class="p">,</span>
    <span class="n">j_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;j&quot;</span><span class="p">,</span>
    <span class="n">relationship_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;relationship&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is meant as a default wrapper for `generate_sib_stats_expr`. It returns a hail table with counts of variants</span>
<span class="sd">    shared by pairs of siblings in `relatedness_ht`.</span>

<span class="sd">    This function takes a hail Table with a row for each pair of individuals i,j in the data that are related (it&#39;s OK to have unrelated samples too).</span>
<span class="sd">    The `relationship_col` should be a column specifying the relationship between each two samples as defined by</span>
<span class="sd">    the constants in `gnomad.utils.relatedness`. This relationship_col will be used to filter to only pairs of</span>
<span class="sd">    samples that are annotated as `SIBLINGS`.</span>

<span class="sd">    :param mt: Input Matrix table</span>
<span class="sd">    :param relatedness_ht: Input relationship table</span>
<span class="sd">    :param sex_ht: A Table containing sex information for the samples</span>
<span class="sd">    :param i_col: Column containing the 1st sample of the pair in the relationship table</span>
<span class="sd">    :param j_col: Column containing the 2nd sample of the pair in the relationship table</span>
<span class="sd">    :param relationship_col: Column containing the relationship for the sample pair as defined in this module constants.</span>
<span class="sd">    :return: A Table with the sibling shared variant counts</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sex_ht</span> <span class="o">=</span> <span class="n">sex_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">is_female</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">sex_ht</span><span class="o">.</span><span class="n">sex_karyotype</span> <span class="o">==</span> <span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">sex_ht</span><span class="o">.</span><span class="n">sex_karyotype</span> <span class="o">==</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="o">.</span><span class="n">or_missing</span><span class="p">()</span>
    <span class="p">)</span>

    <span class="c1"># TODO: Change to use SIBLINGS constant when relatedness PR goes in</span>
    <span class="n">sib_ht</span> <span class="o">=</span> <span class="n">relatedness_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">relatedness_ht</span><span class="p">[</span><span class="n">relationship_col</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;Siblings&quot;</span><span class="p">)</span>
    <span class="n">s_to_keep</span> <span class="o">=</span> <span class="n">sib_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect_as_set</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="p">[</span><span class="n">sib_ht</span><span class="p">[</span><span class="n">i_col</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="p">,</span> <span class="n">sib_ht</span><span class="p">[</span><span class="n">j_col</span><span class="p">]</span><span class="o">.</span><span class="n">s</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="n">_localize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_cols</span><span class="p">(</span><span class="n">s_to_keep</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">s</span><span class="p">))</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">annotate_adj</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">is_female</span><span class="o">=</span><span class="n">sex_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">is_female</span><span class="p">)</span>

    <span class="n">sib_stats_ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span>
        <span class="o">**</span><span class="n">generate_sib_stats_expr</span><span class="p">(</span>
            <span class="n">mt</span><span class="p">,</span>
            <span class="n">sib_ht</span><span class="p">,</span>
            <span class="n">i_col</span><span class="o">=</span><span class="n">i_col</span><span class="p">,</span>
            <span class="n">j_col</span><span class="o">=</span><span class="n">j_col</span><span class="p">,</span>
            <span class="n">strata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;raw&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;adj&quot;</span><span class="p">:</span> <span class="n">mt</span><span class="o">.</span><span class="n">adj</span><span class="p">},</span>
            <span class="n">is_female</span><span class="o">=</span><span class="n">mt</span><span class="o">.</span><span class="n">is_female</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">sib_stats_ht</span></div>
  
 
<div class="viewcode-block" id="get_annotations_hists"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_annotations_hists">[docs]</a><span class="k">def</span> <span class="nf">get_annotations_hists</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">annotations_hists</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
    <span class="n">log10_annotations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates histograms for variant metrics in ht.info.</span>
<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param ht: Table with variant metrics</span>
<span class="sd">    :param annotations_hists: Dictionary of metrics names and their histogram values (start, end, bins)</span>
<span class="sd">    :param log10_annotations: List of metrics to log scale</span>
<span class="sd">    :return: Dictionary of merics and their histograms</span>
<span class="sd">    :rtype: Dict[str, hl.expr.StructExpression]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check all fields in ht.info and create histograms if they are in annotations_hists dict</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="n">field</span><span class="p">])</span> <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">log10_annotations</span> <span class="k">else</span> <span class="n">ht</span><span class="p">[</span><span class="n">field</span><span class="p">],</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="nb">bin</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="ow">in</span> <span class="n">annotations_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">info</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="create_frequency_bins_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.create_frequency_bins_expr">[docs]</a><span class="k">def</span> <span class="nf">create_frequency_bins_expr</span><span class="p">(</span>
    <span class="n">AC</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span> <span class="n">AF</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates bins for frequencies in preparation for aggregating QUAL by frequency bin.</span>

<span class="sd">    Bins: </span>
<span class="sd">        - singleton</span>
<span class="sd">        - doubleton </span>
<span class="sd">        - 0.00005 </span>
<span class="sd">        - 0.0001 </span>
<span class="sd">        - 0.0002</span>
<span class="sd">        - 0.0005</span>
<span class="sd">        - 0.001, </span>
<span class="sd">        - 0.002</span>
<span class="sd">        - 0.005</span>
<span class="sd">        - 0.01</span>
<span class="sd">        - 0.02</span>
<span class="sd">        - 0.05</span>
<span class="sd">        - 0.1</span>
<span class="sd">        - 0.2</span>
<span class="sd">        - 0.5</span>
<span class="sd">        - 1</span>
<span class="sd">    </span>
<span class="sd">    NOTE: Frequencies should be frequencies from raw data.</span>
<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param AC: Field in input that contains the allele count information</span>
<span class="sd">    :param AF: Field in input that contains the allele frequency information</span>
<span class="sd">    :return: Expression containing bin name</span>
<span class="sd">    :rtype: hl.expr.StringExpression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bin_expr</span><span class="o">=</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;binned_singleton&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;binned_doubleton&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.00005</span><span class="p">),</span> <span class="s2">&quot;binned_0.00005&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.00005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">),</span> <span class="s2">&quot;binned_0.0001&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0002</span><span class="p">),</span> <span class="s2">&quot;binned_0.0002&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0005</span><span class="p">),</span> <span class="s2">&quot;binned_0.0005&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">),</span> <span class="s2">&quot;binned_0.001&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.002</span><span class="p">),</span> <span class="s2">&quot;binned_0.002&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.005</span><span class="p">),</span> <span class="s2">&quot;binned_0.005&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">),</span> <span class="s2">&quot;binned_0.01&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="p">),</span> <span class="s2">&quot;binned_0.02&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.02</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">),</span> <span class="s2">&quot;binned_0.05&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">),</span> <span class="s2">&quot;binned_0.1&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">),</span> <span class="s2">&quot;binned_0.2&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">),</span> <span class="s2">&quot;binned_0.5&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;binned_1&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">bin_expr</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>